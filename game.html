<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="theme-color" content="#141516">
<title>UvoWorld</title>
<style>
  :root{
    --bg:#0f1113; --panel:#1d1f22; --accent:#0b84ff; --muted:#9aa0a6;
    --btn-size:72px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;width:100%;margin:0;padding:0;overflow:hidden;background:var(--bg);color:#fff;font-family:Inter,system-ui,Arial;}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#202226,#121315)}
  /* Overlay rotate */
  #rotateOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;background:rgba(3,3,4,0.94);padding:20px;text-align:center}
  #rotateOverlay.hidden{display:none}
  .rotate-box{background:linear-gradient(180deg,#0c0d0e,#121314);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);max-width:420px}
  .rotate-title{font-weight:700;font-size:18px;margin-bottom:8px}
  .rotate-desc{color:var(--muted);margin-bottom:12px;font-size:14px}
  .btn{padding:10px 14px;border-radius:10px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  /* HUD top */
  .hud{position:fixed;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:800;pointer-events:none}
  .hp-box{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#161718);padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:center}
  .hp-bar{width:160px;height:18px;background:#232425;border-radius:10px;overflow:hidden}
  .hp-fill{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#ff2b2b);transition:width .32s}
  .menu{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#141516);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
  /* Controls bottom corners */
  .controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:space-between;align-items:end;padding:0 12px;z-index:900;pointer-events:none}
  .left-corner,.right-corner{pointer-events:auto;display:flex;gap:10px;align-items:center}
  .corner-btn{width:var(--btn-size);height:var(--btn-size);border-radius:12px;background:linear-gradient(180deg,#17181a,#232426);border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .attack-circle{width:86px;height:86px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#0569d6);display:flex;align-items:center;justify-content:center;border:2px solid rgba(0,0,0,0.2);cursor:pointer;box-shadow:0 12px 30px rgba(11,132,255,0.14)}
  .vert-stack{display:flex;flex-direction:column;gap:12px}
  .pressed{transform:translateY(2px) scale(.98);opacity:.96}
  /* toast */
  #toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:var(--accent);padding:8px 14px;border-radius:8px;color:#fff;z-index:1200;opacity:0;transition:opacity .25s}
  #toast.show{opacity:1}
  @media (max-width:700px){:root{--btn-size:60px}.attack-circle{width:70px;height:70px}}
</style>
</head>
<body>
  <div id="gameWrap"><canvas id="gameCanvas" width="1280" height="720"></canvas></div>

  <!-- ROTATE / FULLSCREEN OVERLAY -->
  <div id="rotateOverlay">
    <div class="rotate-box">
      <div class="rotate-title">Mohon Rotasi Device Anda</div>
      <div class="rotate-desc">Aktifkan fullscreen lalu putar perangkat ke <strong>landscape</strong>. Game butuh orientasi landscape untuk kontrol optimal.</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="btnFullLock" class="btn">Aktifkan Fullscreen & Lock</button>
        <button id="btnDismiss" class="btn ghost">Saya Sudah</button>
      </div>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud">
    <div class="hp-box" aria-hidden="false"><svg width="18" height="18" viewBox="0 0 24 24" style="opacity:.95"><path d="M12 21s-8-4.5-8-11a5 5 0 0 1 10 0 5 5 0 0 1 10 0c0 6.5-8 11-8 11z" fill="#ff6b6b"/></svg><div style="font-size:13px;color:var(--muted)">HP</div><div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div></div>
    <div class="menu">Menu</div>
  </div>

  <!-- CONTROLS: left corner arrows; right corner cluster attack-left, (vertical jump & crouch) -->
  <div class="controls">
    <div class="left-corner">
      <button id="btnLeft" class="corner-btn" aria-label="Left">
        <!-- left icon -->
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M15 6L9 12l6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <button id="btnRight" class="corner-btn" aria-label="Right">
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M9 6l6 6-6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
    </div>

    <div style="flex:1"></div>

    <div class="right-corner" style="align-items:flex-end">
      <!-- attack button now LEFT of jump/crouch -->
      <div style="display:flex;gap:10px;align-items:flex-end">
        <button id="btnAttack" class="attack-circle" aria-label="Attack">
          <svg viewBox="0 0 24 24" width="34" height="34" fill="#fff"><path d="M3 21l18-9L3 3v7l12 2-12 2v7z"/></svg>
        </button>

        <div class="vert-stack" style="margin-bottom:6px">
          <button id="btnJump" class="corner-btn" aria-label="Jump">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M12 20V8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M6 14l6-6 6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <button id="btnCrouch" class="corner-btn" aria-label="Crouch">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M4 12h16" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M8 16h8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/></svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite">Game siap</div>

<script>
/* ================== UTILITIES & PROTECTIONS ==================
Improvements:
- Robust state machine supporting required transitions
- Attack combo chaining (attack1 -> attack2 -> attack3)
- Jump/land transitions: landing chooses Idle or Run
- Crouch (hold) and Slide when moving + crouch
- Fall state when in air and landing logic
- Hurt/Die action-locks
- Corner Grab / Climb detection
- Somersault (special) when attack+jump pressed together quickly
- Protections: cooldowns, single pointer, input block on overlays, min state durations, sprite-wait, try/catch main loop
=========================================================== */

const byId = id => document.getElementById(id);
const toast = byId('toast');
function showToast(msg, t=1400){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), t); }

/* Prevent default mobile scroll */
window.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
window.addEventListener('contextmenu', e => e.preventDefault());

/* ORIENTATION / FULLSCREEN overlay */
const rotateOverlay = byId('rotateOverlay');
const btnFullLock = byId('btnFullLock'), btnDismiss = byId('btnDismiss');
function isPortrait(){ return window.innerHeight > window.innerWidth; }
function showOverlay(){ rotateOverlay.classList.remove('hidden'); rotateOverlay.style.display='flex'; }
function hideOverlay(){ rotateOverlay.classList.add('hidden'); rotateOverlay.style.display='none'; }
btnFullLock.addEventListener('click', ()=>{
  const el = document.documentElement;
  if(el.requestFullscreen) el.requestFullscreen().then(()=>{ try{ screen.orientation && screen.orientation.lock && screen.orientation.lock('landscape'); }catch(e){} });
  else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  setTimeout(()=>{ if(!isPortrait()) hideOverlay(); }, 600);
});
btnDismiss.addEventListener('click', ()=>{ if(!isPortrait()) hideOverlay(); else showToast('Silakan putar perangkat ke landscape'); });
window.addEventListener('resize', ()=>{ if(isPortrait()) showOverlay(); else hideOverlay();});
window.addEventListener('orientationchange', ()=> setTimeout(()=>{ if(isPortrait()) showOverlay(); else hideOverlay(); },250) );
if(isPortrait()) showOverlay(); else hideOverlay();

/* CANVAS SETUP */
const canvas = byId('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
let W = window.innerWidth, H = window.innerHeight;
function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

/* WORLD & OBSTACLES (for collision testing & corner detection) */
const GROUND_Y = Math.round(H * 0.78);
const obstacles = [
  // sample obstacle: rectangle platform
  { x: 520, y: GROUND_Y - 80, w: 240, h: 16 },
  { x: 920, y: GROUND_Y - 150, w: 160, h: 16 },
];

/* HERO */
const hero = {
  x: 180, y: GROUND_Y, vx:0, vy:0, dir:1,
  w:48, h:64,
  state:'idle', frame:0, frameTick:0, onGround:true,
  hp:100, stateSince:0,
  stateLock:false, // when true, prevents interruption except forced
  attackStage:0, nextAttackQueued:false,
  prevOnGround:true
};

/* ANIMATIONS — use states matching filenames you uploaded */
const ANIMS = {
  'idle':4,'idle-2':4,'run':6,'jump':4,'fall':2,'attack1':5,'attack2':6,'attack3':6,
  'hurt':3,'die':7,'crouch':4,'slide':2,'smrslt':4,'crnr-clmb':5,'crnr-jmp':3,'crnr-grab':2
};

/* Load sprites with robust fallback */
const SPRITES = {};
let totalToLoad = 0, loadedCount = 0;
for(const k in ANIMS){
  SPRITES[k] = [];
  for(let i=0;i<ANIMS[k];i++){
    totalToLoad++;
    const img = new Image();
    const fname = `asset/hero/adventurer-${k}-${String(i).padStart(2,'0')}.png`;
    img.onload = ()=> loadedCount++;
    img.onerror = ()=> { loadedCount++; console.warn('img load fail', fname); };
    img.src = fname;
    SPRITES[k].push(img);
  }
}

// Protection 7: pause input until some sprites loaded (min threshold)
const SPRITE_MIN_THRESHOLD = Math.min(8, totalToLoad);
let spriteReady = false;
const spriteWaitStart = performance.now();
const SPRITE_WAIT_TIMEOUT = 2000;
(function waitSprites(){
  if(loadedCount >= SPRITE_MIN_THRESHOLD || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    spriteReady = true;
  } else setTimeout(waitSprites, 80);
})();

/* INPUT system with protections */
const INPUT = { left:false, right:false, jump:false, attack:false, crouch:false, up:false };
let activePointerId = null; // protection 11: single pointer
let lastAttackAt = 0, lastJumpAt = 0; // protection 1: cooldowns
const attackCooldownMs = 120, jumpCooldownMs = 120;
let queuedAction = null; // protection 12: limit queued actions

// Protection 10: block inputs if overlay visible
function inputAllowed(){ return spriteReady && rotateOverlay.classList.contains('hidden'); }

/* Unified pointer binding util (protection: pointer capture + single pointer) */
function bindBtn(id, onDown, onUp){
  const el = byId(id);
  if(!el) return;
  el.addEventListener('pointerdown', (ev)=>{
    if(!inputAllowed()) return;
    if(activePointerId !== null && activePointerId !== ev.pointerId) return; // ignore multi pointers
    activePointerId = ev.pointerId;
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    el.classList.add('pressed');
    try{ onDown(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointerup', (ev)=>{
    if(activePointerId !== ev.pointerId) return;
    el.releasePointerCapture && el.releasePointerCapture(ev.pointerId);
    activePointerId = null;
    el.classList.remove('pressed');
    try{ onUp(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointercancel', (ev)=>{ if(activePointerId === ev.pointerId){ activePointerId = null; el.classList.remove('pressed'); onUp(ev);} });
  el.addEventListener('pointerleave', (ev)=>{ if(activePointerId === ev.pointerId){ el.classList.remove('pressed'); }});
}

/* bind controls */
bindBtn('btnLeft', ()=>INPUT.left=true, ()=>INPUT.left=false);
bindBtn('btnRight', ()=>INPUT.right=true, ()=>INPUT.right=false);
bindBtn('btnJump', ()=>{
  if(!inputAllowed()) return;
  const now = performance.now();
  if(now - lastJumpAt < jumpCooldownMs) return;
  lastJumpAt = now;
  INPUT.jump = true;
}, ()=>{ INPUT.jump = false; });

bindBtn('btnAttack', ()=>{
  if(!inputAllowed()) return;
  const now = performance.now();
  if(now - lastAttackAt < attackCooldownMs) return;
  lastAttackAt = now;
  INPUT.attack = true;
  queuedAction = 'attack';
}, ()=>{ INPUT.attack = false; queuedAction = null; });

bindBtn('btnCrouch', ()=>INPUT.crouch = true, ()=>INPUT.crouch = false);

/* Keyboard (desktop) */
window.addEventListener('keydown', (e)=>{
  if(!inputAllowed()) return;
  if(e.repeat) return;
  if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = true;
  if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = true;
  if(e.key === 'ArrowUp' || e.key === 'w') INPUT.up = true;
  if((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && (performance.now() - lastJumpAt > jumpCooldownMs)){
    lastJumpAt = performance.now(); INPUT.jump = true;
  }
  if(e.key === 'j' || e.key === 'k') {
    if(performance.now() - lastAttackAt > attackCooldownMs){ lastAttackAt = performance.now(); INPUT.attack = true; queuedAction='attack'; }
  }
  if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = true;
});
window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = false;
  if(e.key === 'ArrowUp' || e.key === 'w') INPUT.up = false;
  if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = false;
  if(e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') INPUT.jump = false;
});

/* PROTECTION 5: clamp velocities */
const VX_MAX = 12, VY_MAX = 40, VY_MIN = -28;

/* PROTECTION 6: min state durations (ms) to avoid flicker) */
const MIN_STATE_DUR = {
  'attack1': 140, 'attack2': 140, 'attack3':140, 'hurt': 350, 'die': 99999, 'jump': 120, 'fall': 100, 'slide': 220, 'crnr-grab': 120
};

/* helper: loopable states */
const LOOP_STATES = new Set(['idle','run','fall','crouch','idle-2']);

/* SAFETY helpers */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function safeNumber(v,def=0){ return (isFinite(v) && !isNaN(v)) ? v : def; }

/* Collision helpers (AABB) */
function rectOfHero(){
  // hero box anchored by bottom-center
  return { x: hero.x - hero.w/2, y: hero.y - hero.h, w: hero.w, h: hero.h };
}
function rectOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}
function resolveAABBCollision(h, obs){
  // separate axis resolution
  const overlapX = Math.min(h.x + h.w - obs.x, obs.x + obs.w - h.x);
  const overlapY = Math.min(h.y + h.h - obs.y, obs.y + obs.h - h.y);
  if(overlapX <= 0 || overlapY <= 0) return false;
  if(overlapX < overlapY){
    // resolve X
    if(h.x + h.w/2 < obs.x + obs.w/2){
      hero.x -= overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1);
    } else {
      hero.x += overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1);
    }
    return true;
  } else {
    // resolve Y
    if(h.y + h.h/2 < obs.y + obs.h/2){
      // hero above obstacle
      hero.y -= overlapY + 0.5; hero.vy = 0; hero.onGround = true;
    } else {
      // hero below obstacle (bump head)
      hero.y += overlapY + 0.5; hero.vy = Math.max(hero.vy, 0);
    }
    return true;
  }
}

/* STATE machine core */
/* setState: optionally force (bypass locks), optionally lock (non-interruptible) */
function canChangeState(next, force=false){
  if(hero.state === next) return false;
  if(hero.state === 'die' && next !== 'die') return false;
  if(hero.stateLock && !force) return false;
  // allow except die blocking; for safety we don't use priority blocking here,
  // non-interruptible states are controlled via hero.stateLock.
  // MIN_STATE_DUR will still prevent too-frequent switching.
  return true;
}
function setState(next, opts = {force:false, lock:false}){
  const now = performance.now();
  // prevent switching too quickly
  if(!opts.force && MIN_STATE_DUR[hero.state] && now - hero.stateSince < MIN_STATE_DUR[hero.state]) return false;
  if(!canChangeState(next, !!opts.force)) return false;
  hero.state = next;
  hero.frame = 0;
  hero.frameTick = 0;
  hero.stateSince = now;
  hero.stateLock = !!opts.lock;
  return true;
}
/* Force finish of current state (used on animation end) */
function forceState(next){
  return setState(next, {force:true, lock:false});
}

/* helpers for attack combo */
function startAttack(stage){
  stage = Math.max(1, Math.min(3, stage));
  hero.attackStage = stage;
  hero.nextAttackQueued = false;
  setState('attack' + stage, {force:true, lock:true});
}

/* detect corner-edge (simple heuristic) */
function findNearbyEdge(){
  const margin = 18;
  const topTolerance = 10;
  const heroFeetX = hero.x;
  for(const obs of obstacles){
    const topY = obs.y;
    if(Math.abs((hero.y) - topY) <= topTolerance){
      // left edge
      if(Math.abs(heroFeetX - obs.x) <= margin) return {obs, side:'left'};
      if(Math.abs(heroFeetX - (obs.x + obs.w)) <= margin) return {obs, side:'right'};
    }
  }
  return null;
}

/* Flag to detect double-press for somersault (attack + jump together) */
let lastAttackJumpTogether = 0;

/* main update loop (with try/catch protection) */
let last = performance.now();
function update(dt){
  try {
    // safety
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);
    hero.vx = safeNumber(hero.vx, 0); hero.vy = safeNumber(hero.vy, 0);

    // pause inputs until sprite ready
    if(!spriteReady){
      hero.vx *= 0.8; hero.vy += 0.6; // gentle physics but no inputs
      // still progress gravity and basic landing
    } else {
      // process input -> state transitions with respect to locks and combos

      // Detect somersault: attack + jump together (within 160ms of each other)
      if(INPUT.attack && INPUT.jump){
        const now = performance.now();
        if(now - lastAttackJumpTogether > 300){
          lastAttackJumpTogether = now;
        }
        // trigger somersault if on ground and not locked
        if(hero.onGround && canChangeState('smrslt')){
          setState('smrslt', {force:true, lock:true});
          // give small upward impulse
          hero.vy = -10; hero.onGround = false;
        }
      }

      // If in air, prioritize air-specific inputs
      if(!hero.onGround){
        // allow attack in air (optional) but keep state 'jump'/'fall' unless attacking queued
        if(INPUT.attack && canChangeState('attack1') && !hero.stateLock){
          // allow aerial attack as grounded attack? We'll use same combo but unlocked.
          startAttack(1);
        } else {
          // if falling quickly -> fall state
          if(hero.vy > 1 && hero.state !== 'fall') {
            setState('fall', {force:true, lock:false});
          }
        }
      } else {
        // On ground logic
        // attack input -> start/queue combos
        if(INPUT.attack && !hero.stateLock && (performance.now() - hero.stateSince > 40)){
          // start combo
          startAttack(1);
        } else if(INPUT.attack && hero.state && hero.state.startsWith('attack') && hero.stateLock){
          // if during attack we press attack quickly, queue next stage
          if(hero.attackStage > 0 && hero.attackStage < 3) {
            hero.nextAttackQueued = true;
          }
        }

        // crouch/slide: if crouching and moving -> slide
        if(INPUT.crouch && (INPUT.left || INPUT.right) && hero.onGround && !hero.stateLock){
          if(setState('slide', {force:true, lock:true})){
            // slide impulse
            hero.vx = (INPUT.right ? 6 : -6);
          }
        } else if(INPUT.crouch && !INPUT.left && !INPUT.right && hero.onGround && !hero.stateLock){
          // hold crouch
          setState('crouch', {force:true, lock:false});
          hero.vx *= 0.6;
        }

        // corner grab: if near edge and press up
        const edge = findNearbyEdge();
        if(edge && INPUT.up && hero.onGround && !hero.stateLock){
          // grab the corner
          setState('crnr-grab', {force:true, lock:true});
        }

        // jump consumption (single impulse)
        if(INPUT.jump && hero.onGround && !hero.stateLock){
          hero.vy = -13.2; hero.onGround = false;
          // keep running momentum if was running
          if(hero.state === 'run' || INPUT.left || INPUT.right) {
            setState('jump', {force:true, lock:false});
          } else {
            setState('jump', {force:true, lock:false});
          }
          INPUT.jump = false;
        }

        // run vs idle while on ground (only when not locked by action)
        if(!hero.stateLock){
          if(INPUT.left || INPUT.right){
            hero.dir = INPUT.right ? 1 : -1;
            setState('run', {force:false, lock:false});
            // accelerate
            hero.vx += (INPUT.right ? 1 : -1) * 0.9;
          } else {
            setState('idle', {force:false, lock:false});
            hero.vx *= 0.78;
          }
        }
      } // end onGround branch
    }

    // physics
    hero.vy += 0.66;
    // clamps (protection 5)
    hero.vx = clamp(hero.vx, -VX_MAX, VX_MAX);
    hero.vy = clamp(hero.vy, VY_MIN, VY_MAX);

    // apply friction on ground when not moving
    if(hero.onGround && !INPUT.left && !INPUT.right && !hero.stateLock){
      hero.vx *= 0.7;
    }

    hero.x += hero.vx;
    hero.y += hero.vy;

    // base ground
    const wasOnGround = hero.onGround;
    if(hero.y >= GROUND_Y){
      if(!wasOnGround && Math.abs(hero.vy) > 18){
        // heavy landing => hurt
        hero.hp = clamp(hero.hp - 8, 0, 100);
        setState('hurt', {force:true, lock:true});
      }
      hero.y = GROUND_Y; hero.vy = 0; hero.onGround = true;
    } else hero.onGround = false;

    // obstacle collisions (protection 8)
    const hRect = rectOfHero();
    for(const obs of obstacles){
      if(rectOverlap(hRect, obs)) {
        resolveAABBCollision(hRect, obs);
      }
    }

    // landing detection: just landed this frame
    if(!wasOnGround && hero.onGround){
      // landing completes jump/fall
      // if currently in a locking jump state, we should release and transition based on inputs
      // If hero was in 'jump' or 'fall' state or 'smrslt', pick next state
      // unlock any non-die/hurt locks that were air-only
      hero.stateLock = hero.state === 'die' || hero.state === 'hurt';
      if(hero.state === 'smrslt' || hero.state === 'jump' || hero.state === 'fall'){
        if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
      }
    }

    // obstacle edge climb finalization (if in crnr-grab and up pressed again -> climb)
    if(hero.state === 'crnr-grab' && hero.stateLock){
      // allow second up press to climb
      if(INPUT.up){
        setState('crnr-clmb', {force:true, lock:true});
      }
    }
    if(hero.state === 'crnr-clmb'){
      // after animation end we'll reposition hero on top
      // but actual position setting occurs in animation complete handler
    }

    // clamp hero inside world bounds (protection 1)
    hero.x = clamp(hero.x, 32, Math.max(600, W - 32));

    // animation tick: protection 2 & 3 (frame safe checks)
    hero.frameTick += Math.max(1, Math.floor(dt / 16));
    const animMeta = ANIMS[hero.state] || ANIMS['idle'];
    const ticksPerFrame = (hero.state === 'run' ? 4 : (hero.state.startsWith('attack') ? 6 : 8));
    if(hero.frameTick >= ticksPerFrame){
      hero.frameTick = 0;
      hero.frame++;
      if(hero.frame >= animMeta){
        // animation ended
        handleAnimationComplete(hero.state);
      }
    }

    // protection 11: reset queuedAction after processing if unused
    if(queuedAction && queuedAction === 'attack' && !INPUT.attack) queuedAction = null;

    // protection 9 ensure safe numbers
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);

  } catch(err){
    console.error('update error', err);
    // protection 13: don't crash loop - attempt safe reset
    hero.vx = 0; hero.vy = 0; hero.state = 'idle'; hero.frame = 0; hero.stateLock = false;
  }
}

/* Handle logic when an animation finishes (non-looping or reached last frame) */
function handleAnimationComplete(stateEnded){
  // If animation is loopable, reset frame normally
  if(LOOP_STATES.has(stateEnded)){
    hero.frame = hero.frame % (ANIMS[stateEnded] || 1);
    return;
  }

  // Attack combo handling
  if(stateEnded.startsWith('attack')){
    // if queued next attack -> advance combo
    if(hero.nextAttackQueued && hero.attackStage < 3){
      startAttack(hero.attackStage + 1); // will set stateLock true
      return;
    } else {
      // finish combo: unlock and go to run/idle depending on inputs
      hero.attackStage = 0; hero.nextAttackQueued = false; hero.stateLock = false;
      if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
      return;
    }
  }

  // Slide finished -> to run/idle
  if(stateEnded === 'slide'){
    hero.stateLock = false;
    hero.vx = 0;
    if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
    return;
  }

  // Crouch ended? (crouch is hold-based, so just loop)
  if(stateEnded === 'crouch'){
    if(INPUT.crouch) {
      hero.frame = 0; // keep crouch
      return;
    } else {
      hero.stateLock = false;
      if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
      return;
    }
  }

  // Jump/Smrslt/Fall: when their animation finishes, if on ground go to run/idle, else go to fall
  if(stateEnded === 'jump' || stateEnded === 'smrslt' || stateEnded === 'fall'){
    hero.stateLock = false;
    if(hero.onGround){
      if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
    } else {
      forceState('fall');
    }
    return;
  }

  // Corner grab/climb
  if(stateEnded === 'crnr-grab'){
    // if still grabbing but no second up -> remain grabbed briefly
    hero.frame = 0; // keep small hold
    return;
  }
  if(stateEnded === 'crnr-clmb'){
    // reposition hero on top of the platform nearest the edge
    const edge = findNearbyEdge();
    if(edge){
      // place hero on top-center slightly inward
      hero.y = edge.obs.y;
      if(edge.side === 'left') hero.x = edge.obs.x + 20;
      else hero.x = edge.obs.x + edge.obs.w - 20;
    }
    hero.stateLock = false;
    if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
    return;
  }

  // Hurt finished -> resume based on movement
  if(stateEnded === 'hurt'){
    hero.stateLock = false;
    if(hero.hp <= 0) { setState('die', {force:true, lock:true}); return; }
    if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
    return;
  }

  // Die: stay in die (non-interruptible)
  if(stateEnded === 'die'){
    hero.stateLock = true;
    // disable inputs (handled globally by checking hero.state === 'die')
    return;
  }

  // Generic default: if on ground -> idle/run, else fall
  if(hero.onGround){
    if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
  } else {
    forceState('fall');
  }
}

/* DRAW with protections */
function draw(){
  try {
    ctx.clearRect(0,0,W,H);
    // background
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#242628'); g.addColorStop(1,'#101214');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // obstacles
    for(const obs of obstacles){
      ctx.fillStyle = '#2b2c2f';
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
    }

    // hero draw (protection 3 & 4 & 15)
    const animSet = SPRITES[hero.state] && SPRITES[hero.state].length ? SPRITES[hero.state] : (SPRITES['idle'] || []);
    const frameIndex = hero.frame % (animSet.length || 1);
    const img = animSet[frameIndex] || null;
    if(img && img.complete && img.naturalWidth){
      const scale = Math.max(1.2, Math.min(2.0, (H/720) * 1.8));
      const w = img.width * scale, h = img.height * scale;
      ctx.save();
      ctx.translate(hero.x, hero.y);
      ctx.scale(hero.dir, 1);
      try {
        ctx.drawImage(img, -w/2, -h, w, h);
      } catch(e){
        // fallback: rectangle when drawImage fails (protection 3)
        ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h);
      }
      ctx.restore();
    } else {
      ctx.save(); ctx.translate(hero.x, hero.y);
      ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h);
      ctx.restore();
    }

    // debug: show state text (optional)
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '14px system-ui';
    ctx.fillText(`State: ${hero.state} ${hero.stateLock ? '(locked)':''}`, 12, 60);
    ctx.fillText(`OnGround:${hero.onGround} vx:${hero.vx.toFixed(2)} vy:${hero.vy.toFixed(2)}`, 12, 80);

    // overlays like HUD shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0,0,W,48);

  } catch(err){
    console.error('draw error', err);
  }
}

/* GAME LOOP (time-based) */
let lastT = performance.now();
function loop(now){
  try {
    const dt = now - lastT; lastT = now;
    // if hero is dead, block inputs
    if(hero.state === 'die') {
      INPUT.left = INPUT.right = INPUT.jump = INPUT.attack = INPUT.crouch = false;
    }
    update(dt); draw();
  } catch(e){ console.error('main loop error', e); }
  requestAnimationFrame(loop);
}

// start once some sprites loaded (protection 7)
(function startWhenReady(){
  if(spriteReady || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    lastT = performance.now();
    requestAnimationFrame(loop);
    showToast('Siap! Gunakan kontrol pojok untuk main');
  } else {
    setTimeout(startWhenReady, 80);
  }
})();

/* update UI HP bar */
setInterval(()=>{ const hb = byId('hpFill'); if(hb) hb.style.width = hero.hp + '%'; }, 120);

/* protection 15: remove watermark if any */
setTimeout(()=>{
  Array.from(document.querySelectorAll('img,div')).forEach(el=>{
    try{
      if(el.innerText && /apkpure/i.test(el.innerText)) el.remove();
      if(el.src && typeof el.src === 'string' && /apkpure/i.test(el.src)) el.remove();
    }catch(e){}
  });
}, 900);

/* safety: clear inputs when tab hidden */
document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ INPUT.left = INPUT.right = INPUT.attack = INPUT.jump = INPUT.crouch = false; } });

/* show hint for desktop */
if(window.innerWidth > 900) setTimeout(()=> showToast('Gunakan A/D atau Panah ← → untuk bergerak, Space untuk lompat, J untuk serang'), 1200);
</script>
</body>
</html>
