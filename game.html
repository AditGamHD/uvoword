<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="theme-color" content="#141516">
<title>UvoWorld — Fix Animations & Protections</title>
<style>
  :root{
    --bg:#0f1113; --panel:#1d1f22; --accent:#0b84ff; --muted:#9aa0a6;
    --btn-size:72px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;width:100%;margin:0;padding:0;overflow:hidden;background:var(--bg);color:#fff;font-family:Inter,system-ui,Arial;}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#202226,#121315)}
  /* Overlay rotate */
  #rotateOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;background:rgba(3,3,4,0.94);padding:20px;text-align:center}
  #rotateOverlay.hidden{display:none}
  .rotate-box{background:linear-gradient(180deg,#0c0d0e,#121314);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);max-width:420px}
  .rotate-title{font-weight:700;font-size:18px;margin-bottom:8px}
  .rotate-desc{color:var(--muted);margin-bottom:12px;font-size:14px}
  .btn{padding:10px 14px;border-radius:10px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  /* HUD top */
  .hud{position:fixed;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:800;pointer-events:none}
  .hp-box{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#161718);padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:center}
  .hp-bar{width:160px;height:18px;background:#232425;border-radius:10px;overflow:hidden}
  .hp-fill{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#ff2b2b);transition:width .32s}
  .menu{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#141516);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
  /* Controls bottom corners */
  .controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:space-between;align-items:end;padding:0 12px;z-index:900;pointer-events:none}
  .left-corner,.right-corner{pointer-events:auto;display:flex;gap:10px;align-items:center}
  .corner-btn{width:var(--btn-size);height:var(--btn-size);border-radius:12px;background:linear-gradient(180deg,#17181a,#232426);border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .attack-circle{width:86px;height:86px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#0569d6);display:flex;align-items:center;justify-content:center;border:2px solid rgba(0,0,0,0.2);cursor:pointer;box-shadow:0 12px 30px rgba(11,132,255,0.14)}
  .vert-stack{display:flex;flex-direction:column;gap:12px}
  .pressed{transform:translateY(2px) scale(.98);opacity:.96}
  /* toast */
  #toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:var(--accent);padding:8px 14px;border-radius:8px;color:#fff;z-index:1200;opacity:0;transition:opacity .25s}
  #toast.show{opacity:1}
  @media (max-width:700px){:root{--btn-size:60px}.attack-circle{width:70px;height:70px}}
</style>
</head>
<body>
  <div id="gameWrap"><canvas id="gameCanvas" width="1280" height="720"></canvas></div>

  <!-- ROTATE / FULLSCREEN OVERLAY -->
  <div id="rotateOverlay">
    <div class="rotate-box">
      <div class="rotate-title">Mohon Rotasi Device Anda</div>
      <div class="rotate-desc">Aktifkan fullscreen lalu putar perangkat ke <strong>landscape</strong>. Game butuh orientasi landscape untuk kontrol optimal.</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="btnFullLock" class="btn">Aktifkan Fullscreen & Lock</button>
        <button id="btnDismiss" class="btn ghost">Saya Sudah</button>
      </div>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud">
    <div class="hp-box" aria-hidden="false"><svg width="18" height="18" viewBox="0 0 24 24" style="opacity:.95"><path d="M12 21s-8-4.5-8-11a5 5 0 0 1 10 0 5 5 0 0 1 10 0c0 6.5-8 11-8 11z" fill="#ff6b6b"/></svg><div style="font-size:13px;color:var(--muted)">HP</div><div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div></div>
    <div class="menu">Menu</div>
  </div>

  <!-- CONTROLS: left corner arrows; right corner cluster attack-left, (vertical jump & crouch) -->
  <div class="controls">
    <div class="left-corner">
      <button id="btnLeft" class="corner-btn" aria-label="Left">
        <!-- left icon -->
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M15 6L9 12l6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <button id="btnRight" class="corner-btn" aria-label="Right">
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M9 6l6 6-6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
    </div>

    <div style="flex:1"></div>

    <div class="right-corner" style="align-items:flex-end">
      <!-- attack button now LEFT of jump/crouch -->
      <div style="display:flex;gap:10px;align-items:flex-end">
        <button id="btnAttack" class="attack-circle" aria-label="Attack">
          <svg viewBox="0 0 24 24" width="34" height="34" fill="#fff"><path d="M3 21l18-9L3 3v7l12 2-12 2v7z"/></svg>
        </button>

        <div class="vert-stack" style="margin-bottom:6px">
          <button id="btnJump" class="corner-btn" aria-label="Jump">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M12 20V8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M6 14l6-6 6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <button id="btnCrouch" class="corner-btn" aria-label="Crouch">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M4 12h16" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M8 16h8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/></svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite">Game siap</div>

<script>
/* ================== UTILITIES & PROTECTIONS LIST ==================
We will implement 15 protections in code:
1) Input debounce & cooldown for attack/jump (attackCooldownMs, jumpCooldownMs)
2) Action-lock for non-interruptible states (attack/hurt/die)
3) Frame-index safe checks before drawing
4) Fallback sprite mapping if missing
5) Clamp velocities to max limits
6) Minimum state duration to prevent flicker
7) Pause input until minimum sprites loaded
8) Collision resolution with separate-axis separation (AABB)
9) NaN/Infinity checks (reset to safe values)
10) Overlay blocking input when rotate/overlay active
11) Single-pointer tracking to avoid multi-touch edge cases
12) Limit queued input actions to 1 (prevent spam)
13) Try/catch around main loop to prevent fatal crash
14) Prevent pointer default scroll/drag on window
15) Remove external watermark heuristically (best-effort)
=========================================================== */

const byId = id => document.getElementById(id);
const toast = byId('toast');
function showToast(msg, t=1400){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), t); }

/* Prevent default mobile scroll */
window.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
window.addEventListener('contextmenu', e => e.preventDefault());

/* ORIENTATION / FULLSCREEN overlay */
const rotateOverlay = byId('rotateOverlay');
const btnFullLock = byId('btnFullLock'), btnDismiss = byId('btnDismiss');

function isPortrait(){ return window.innerHeight > window.innerWidth; }
function showOverlay(){ rotateOverlay.classList.remove('hidden'); rotateOverlay.style.display='flex'; }
function hideOverlay(){ rotateOverlay.classList.add('hidden'); rotateOverlay.style.display='none'; }

btnFullLock.addEventListener('click', ()=>{
  const el = document.documentElement;
  if(el.requestFullscreen) el.requestFullscreen().then(()=>{ try{ screen.orientation && screen.orientation.lock && screen.orientation.lock('landscape'); }catch(e){} });
  else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  setTimeout(()=>{ if(!isPortrait()) hideOverlay(); }, 600);
});
btnDismiss.addEventListener('click', ()=>{ if(!isPortrait()) hideOverlay(); else showToast('Silakan putar perangkat ke landscape'); });

window.addEventListener('resize', ()=>{ if(isPortrait()) showOverlay(); else hideOverlay();});
window.addEventListener('orientationchange', ()=> setTimeout(()=>{ if(isPortrait()) showOverlay(); else hideOverlay(); },250) );
if(isPortrait()) showOverlay(); else hideOverlay();

/* CANVAS SETUP */
const canvas = byId('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
let W = window.innerWidth, H = window.innerHeight;
function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

/* WORLD & OBSTACLES (for collision testing) */
const GROUND_Y = Math.round(H * 0.78);
const obstacles = [
  // sample obstacle: rectangle platform
  { x: 520, y: GROUND_Y - 80, w: 240, h: 16 },
  { x: 920, y: GROUND_Y - 150, w: 160, h: 16 },
];

/* HERO */
const hero = {
  x: 180, y: GROUND_Y, vx:0, vy:0, dir:1,
  w:48, h:64,
  state:'idle', frame:0, frameTick:0, onGround:true, hp:100, stateSince:0
};

/* ANIMATIONS — use states matching filenames you uploaded */
const ANIMS = {
  'idle':4,'idle-2':4,'run':6,'jump':4,'fall':2,'attack1':5,'attack2':6,'attack3':6,
  'hurt':3,'die':7,'crouch':4,'slide':2,'smrslt':4,'crnr-clmb':5,'crnr-jmp':3
};

/* Load sprites with robust fallback */
const SPRITES = {};
let totalToLoad = 0, loadedCount = 0;
for(const k in ANIMS){
  SPRITES[k] = [];
  for(let i=0;i<ANIMS[k];i++){
    totalToLoad++;
    const img = new Image();
    const fname = `asset/hero/adventurer-${k}-${String(i).padStart(2,'0')}.png`;
    img.onload = ()=> loadedCount++;
    img.onerror = ()=> { loadedCount++; console.warn('img load fail', fname); };
    img.src = fname;
    SPRITES[k].push(img);
  }
}

// Protection 7: pause input until some sprites loaded (min threshold)
const SPRITE_MIN_THRESHOLD = Math.min(6, totalToLoad);
let spriteReady = false;
const spriteWaitStart = performance.now();
const SPRITE_WAIT_TIMEOUT = 1500;
(function waitSprites(){
  if(loadedCount >= SPRITE_MIN_THRESHOLD || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    spriteReady = true;
  } else setTimeout(waitSprites, 80);
})();

/* INPUT system with protections */
const INPUT = { left:false, right:false, jump:false, attack:false, crouch:false };
let activePointerId = null; // protection 11: single pointer
let lastAttackAt = 0, lastJumpAt = 0; // protection 1: cooldowns
const attackCooldownMs = 420, jumpCooldownMs = 220;
let queuedAction = null; // protection 12: limit queued actions

// Protection 10: block inputs if overlay visible
function inputAllowed(){ return spriteReady && rotateOverlay.classList.contains('hidden'); }

/* Unified pointer binding util (protection: pointer capture + single pointer) */
function bindBtn(id, onDown, onUp){
  const el = byId(id);
  if(!el) return;
  el.addEventListener('pointerdown', (ev)=>{
    if(!inputAllowed()) return;
    if(activePointerId !== null && activePointerId !== ev.pointerId) return; // ignore multi pointers
    activePointerId = ev.pointerId;
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    el.classList.add('pressed');
    try{ onDown(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointerup', (ev)=>{
    if(activePointerId !== ev.pointerId) return;
    el.releasePointerCapture && el.releasePointerCapture(ev.pointerId);
    activePointerId = null;
    el.classList.remove('pressed');
    try{ onUp(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointercancel', (ev)=>{ if(activePointerId === ev.pointerId){ activePointerId = null; el.classList.remove('pressed'); onUp(ev);} });
  el.addEventListener('pointerleave', (ev)=>{ if(activePointerId === ev.pointerId){ el.classList.remove('pressed'); }});
}

/* bind controls */
bindBtn('btnLeft', ()=>INPUT.left=true, ()=>INPUT.left=false);
bindBtn('btnRight', ()=>INPUT.right=true, ()=>INPUT.right=false);
bindBtn('btnJump', ()=>{
  if(!inputAllowed()) return;
  const now = performance.now();
  if(now - lastJumpAt < jumpCooldownMs) return;
  lastJumpAt = now;
  INPUT.jump = true;
}, ()=>{ INPUT.jump = false; });

bindBtn('btnAttack', ()=>{
  if(!inputAllowed()) return;
  const now = performance.now();
  if(now - lastAttackAt < attackCooldownMs) return;
  lastAttackAt = now;
  INPUT.attack = true;
  // queue limited
  queuedAction = 'attack';
}, ()=>{ INPUT.attack = false; queuedAction = null; });

bindBtn('btnCrouch', ()=>INPUT.crouch = true, ()=>INPUT.crouch = false);

/* Keyboard (desktop) */
window.addEventListener('keydown', (e)=>{
  if(!inputAllowed()) return;
  if(e.repeat) return;
  if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = true;
  if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = true;
  if((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && (performance.now() - lastJumpAt > jumpCooldownMs)){
    lastJumpAt = performance.now(); INPUT.jump = true;
  }
  if(e.key === 'j' || e.key === 'k') {
    if(performance.now() - lastAttackAt > attackCooldownMs){ lastAttackAt = performance.now(); INPUT.attack = true; queuedAction='attack'; }
  }
  if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = true;
});
window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = false;
  if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = false;
  if(e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') INPUT.jump = false;
});

/* PROTECTION 5: clamp velocities */
const VX_MAX = 12, VY_MAX = 40, VY_MIN = -28;

/* PROTECTION 6: min state durations (ms) to avoid flicker) */
const MIN_STATE_DUR = {
  'attack1': 300, 'attack2': 300, 'attack3':300, 'hurt': 400, 'die': 99999, 'jump': 180, 'fall': 120
};

/* SAFETY helpers */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function safeNumber(v,def=0){ return (isFinite(v) && !isNaN(v)) ? v : def; }

/* Collision helpers (AABB) */
function rectOfHero(){
  // hero box anchored by bottom-center
  return { x: hero.x - hero.w/2, y: hero.y - hero.h, w: hero.w, h: hero.h };
}
function rectOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}
function resolveAABBCollision(h, obs){
  // separate axis resolution
  const overlapX = Math.min(h.x + h.w - obs.x, obs.x + obs.w - h.x);
  const overlapY = Math.min(h.y + h.h - obs.y, obs.y + obs.h - h.y);
  if(overlapX <= 0 || overlapY <= 0) return false;
  if(overlapX < overlapY){
    // resolve X
    if(h.x + h.w/2 < obs.x + obs.w/2){
      hero.x -= overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1);
    } else {
      hero.x += overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1);
    }
    return true;
  } else {
    // resolve Y
    if(h.y + h.h/2 < obs.y + obs.h/2){
      // hero above obstacle
      hero.y -= overlapY + 0.5; hero.vy = 0; hero.onGround = true;
    } else {
      // hero below obstacle (bump head)
      hero.y += overlapY + 0.5; hero.vy = Math.max(hero.vy, 0);
    }
    return true;
  }
}

/* STATE machine with priority & protections */
const PRIORITY = { die:90, hurt:80, attack1:70, attack2:70, attack3:70, jump:60, fall:50, crouch:40, run:30, idle:10 };
function canChangeState(next){
  const curr = hero.state;
  if(curr === next) return false;
  if(curr === 'die') return false;
  const now = performance.now();
  if(MIN_STATE_DUR[curr] && now - hero.stateSince < MIN_STATE_DUR[curr]) return false;
  const curP = PRIORITY[curr] || 0, nextP = PRIORITY[next] || 0;
  if(nextP < curP) return false;
  return true;
}
function setState(next){
  if(!canChangeState(next)) return false;
  hero.state = next; hero.frame = 0; hero.frameTick = 0; hero.stateSince = performance.now();
  return true;
}

/* main update loop (with try/catch protection) */
let last = performance.now();
function update(dt){
  try {
    // protection 9: NaN safety
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);
    hero.vx = safeNumber(hero.vx, 0); hero.vy = safeNumber(hero.vy, 0);

    // pause inputs until sprite ready
    if(!spriteReady){
      hero.vx *= 0.8; hero.vy += 0.6; // gentle physics but no inputs
    } else {
      // input handling with priority
      // Attack priority
      if(INPUT.attack && performance.now() - hero.stateSince > 60){
        if(setState('attack1')) { /* attack started */ }
      } else if(!hero.onGround){
        if(hero.vy < -1) setState('jump'); else setState('fall');
      } else if(INPUT.crouch){
        setState('crouch');
      } else if(INPUT.left || INPUT.right){
        hero.dir = INPUT.right ? 1 : -1;
        setState('run');
        // accelerate
        hero.vx += (INPUT.right ? 1 : -1) * 0.9;
      } else {
        setState('idle');
        hero.vx *= 0.82;
      }

      // jump consumption (single impulse)
      if(INPUT.jump && hero.onGround){
        hero.vy = -13.2; hero.onGround = false; setState('jump'); INPUT.jump = false;
      }
    }

    // physics
    hero.vy += 0.66;
    // clamps (protection 5)
    hero.vx = clamp(hero.vx, -VX_MAX, VX_MAX);
    hero.vy = clamp(hero.vy, VY_MIN, VY_MAX);

    hero.x += hero.vx;
    hero.y += hero.vy;

    // base ground
    if(hero.y >= GROUND_Y){
      if(!hero.onGround && Math.abs(hero.vy) > 18){
        // heavy landing => hurt
        hero.hp = clamp(hero.hp - 8, 0, 100);
        setState('hurt');
      }
      hero.y = GROUND_Y; hero.vy = 0; hero.onGround = true;
    } else hero.onGround = false;

    // obstacle collisions (protection 8)
    const hRect = rectOfHero();
    for(const obs of obstacles){
      if(rectOverlap(hRect, obs)) {
        resolveAABBCollision(hRect, obs);
      }
    }

    // clamp hero inside world bounds (protection 1)
    hero.x = clamp(hero.x, 32, Math.max(600, W - 32));

    // animation tick: protection 2 & 3 (frame safe checks)
    hero.frameTick += Math.max(1, Math.floor(dt / 16));
    const animMeta = ANIMS[hero.state] || ANIMS['idle'];
    const ticksPerFrame = (hero.state === 'run' ? 4 : (hero.state.startsWith('attack') ? 6 : 8));
    if(hero.frameTick >= ticksPerFrame){
      hero.frameTick = 0;
      hero.frame++;
      if(hero.frame >= animMeta){
        if(animMeta && animMeta > 0){
          // finalize non-looping
          const loopStates = ['idle','run','fall','crouch'];
          if(loopStates.includes(hero.state)) hero.frame = hero.frame % animMeta;
          else {
            // return to idle or appropriate state
            if(hero.onGround) setState('idle'); else setState('fall');
          }
        } else {
          hero.frame = 0;
        }
      }
    }

    // protection 11: reset queuedAction after processing
    if(queuedAction && queuedAction === 'attack' && hero.state !== 'attack1') queuedAction = null;

    // protection 9 ensure safe numbers
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);

  } catch(err){
    console.error('update error', err);
    // protection 13: don't crash loop - attempt safe reset
    hero.vx = 0; hero.vy = 0; hero.state = 'idle'; hero.frame = 0;
  }
}

/* DRAW with protections */
function draw(){
  try {
    ctx.clearRect(0,0,W,H);
    // background
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#242628'); g.addColorStop(1,'#101214');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // obstacles
    for(const obs of obstacles){
      ctx.fillStyle = '#2b2c2f';
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
    }

    // hero draw (protection 3 & 4 & 15)
    const animSet = SPRITES[hero.state] && SPRITES[hero.state].length ? SPRITES[hero.state] : (SPRITES['idle'] || []);
    const frameIndex = hero.frame % (animSet.length || 1);
    const img = animSet[frameIndex] || null;
    if(img && img.complete && img.naturalWidth){
      const scale = Math.max(1.4, Math.min(2.0, (H/720) * 1.9));
      const w = img.width * scale, h = img.height * scale;
      ctx.save();
      ctx.translate(hero.x, hero.y);
      ctx.scale(hero.dir, 1);
      try {
        ctx.drawImage(img, -w/2, -h, w, h);
      } catch(e){
        // fallback: rectangle when drawImage fails (protection 3)
        ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h);
      }
      ctx.restore();
    } else {
      ctx.save(); ctx.translate(hero.x, hero.y);
      ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h);
      ctx.restore();
    }

    // overlays like HUD shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0,0,W,48);

  } catch(err){
    console.error('draw error', err);
  }
}

/* GAME LOOP (time-based) */
let lastT = performance.now();
function loop(now){
  try {
    const dt = now - lastT; lastT = now;
    update(dt); draw();
  } catch(e){ console.error('main loop error', e); }
  requestAnimationFrame(loop);
}

// start once some sprites loaded (protection 7)
(function startWhenReady(){
  if(spriteReady || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    lastT = performance.now();
    requestAnimationFrame(loop);
    showToast('Siap! Gunakan kontrol pojok untuk main');
  } else {
    setTimeout(startWhenReady, 80);
  }
})();

/* update UI HP bar */
setInterval(()=>{ const hb = byId('hpFill'); if(hb) hb.style.width = hero.hp + '%'; }, 120);

/* protection 15: remove watermark if any */
setTimeout(()=>{
  Array.from(document.querySelectorAll('img,div')).forEach(el=>{
    try{
      if(el.innerText && /apkpure/i.test(el.innerText)) el.remove();
      if(el.src && typeof el.src === 'string' && /apkpure/i.test(el.src)) el.remove();
    }catch(e){}
  });
}, 900);

/* safety: clear inputs when tab hidden */
document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ INPUT.left = INPUT.right = INPUT.attack = INPUT.jump = INPUT.crouch = false; } });

/* show hint for desktop */
if(window.innerWidth > 900) setTimeout(()=> showToast('Gunakan A/D atau Panah ← → untuk bergerak, Space untuk lompat, J untuk serang'), 1200);
</script>
</body>
</html>
