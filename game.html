<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="theme-color" content="#141516">
<title>UvoWorld — Fix Animations & Protections (Fixed)</title>
<style>
  :root{
    --bg:#0f1113; --panel:#1d1f22; --accent:#0b84ff; --muted:#9aa0a6;
    --btn-size:72px; --hp-green: #4ade80; --hp-yellow:#f59e0b; --hp-red:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%;width:100%;margin:0;padding:0;overflow:hidden;background:var(--bg);color:#fff;font-family:Inter,system-ui,Arial;}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#202226,#121315)}
  /* Overlay rotate */
  #rotateOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;background:rgba(3,3,4,0.94);padding:20px;text-align:center}
  #rotateOverlay.hidden{display:none}
  .rotate-box{background:linear-gradient(180deg,#0c0d0e,#121314);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);max-width:420px}
  .rotate-title{font-weight:700;font-size:18px;margin-bottom:8px}
  .rotate-desc{color:var(--muted);margin-bottom:12px;font-size:14px}
  .btn{padding:10px 14px;border-radius:10px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  /* HUD top */
  .hud{position:fixed;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:800;pointer-events:none}
  .hp-box{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#161718);padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:center;min-width:220px}
  .hp-bar{width:160px;height:18px;background:#232425;border-radius:10px;overflow:hidden;position:relative}
  .hp-fill{height:100%;width:100%;background:linear-gradient(90deg,var(--hp-green),#10b981);transition:width .32s,background .32s}
  .hp-text{font-size:13px;color:var(--muted);min-width:44px;text-align:right}
  .menu{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#141516);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
  /* Controls bottom corners */
  .controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:space-between;align-items:end;padding:0 12px;z-index:900;pointer-events:none}
  .left-corner,.right-corner{pointer-events:auto;display:flex;gap:10px;align-items:center}
  .corner-btn{width:var(--btn-size);height:var(--btn-size);border-radius:12px;background:linear-gradient(180deg,#17181a,#232426);border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .attack-circle{width:86px;height:86px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#0569d6);display:flex;align-items:center;justify-content:center;border:2px solid rgba(0,0,0,0.2);cursor:pointer;box-shadow:0 12px 30px rgba(11,132,255,0.14)}
  .vert-stack{display:flex;flex-direction:column;gap:12px}
  .pressed{transform:translateY(2px) scale(.98);opacity:.96}
  /* toast */
  #toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:var(--accent);padding:8px 14px;border-radius:8px;color:#fff;z-index:1200;opacity:0;transition:opacity .25s}
  #toast.show{opacity:1}
  @media (max-width:700px){:root{--btn-size:60px}.attack-circle{width:70px;height:70px}}
</style>
</head>
<body>
  <div id="gameWrap"><canvas id="gameCanvas" width="1280" height="720"></canvas></div>

  <!-- ROTATE / FULLSCREEN OVERLAY -->
  <div id="rotateOverlay">
    <div class="rotate-box">
      <div class="rotate-title">Mohon Rotasi Device Anda</div>
      <div class="rotate-desc">Aktifkan fullscreen lalu putar perangkat ke <strong>landscape</strong>. Game butuh orientasi landscape untuk kontrol optimal.</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="btnFullLock" class="btn">Aktifkan Fullscreen & Lock</button>
        <button id="btnDismiss" class="btn ghost">Saya Sudah</button>
      </div>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud">
    <div class="hp-box" aria-hidden="false">
      <svg width="18" height="18" viewBox="0 0 24 24" style="opacity:.95"><path d="M12 21s-8-4.5-8-11a5 5 0 0 1 10 0 5 5 0 0 1 10 0c0 6.5-8 11-8 11z" fill="#ff6b6b"/></svg>
      <div style="font-size:13px;color:var(--muted)">HP</div>
      <div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div>
      <div class="hp-text" id="hpText">100%</div>
    </div>
    <div class="menu">Menu</div>
  </div>

  <!-- CONTROLS: left corner arrows; right corner cluster attack-left, (vertical jump & crouch) -->
  <div class="controls">
    <div class="left-corner">
      <button id="btnLeft" class="corner-btn" aria-label="Left">
        <!-- left icon -->
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M15 6L9 12l6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <button id="btnRight" class="corner-btn" aria-label="Right">
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M9 6l6 6-6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
    </div>

    <div style="flex:1"></div>

    <div class="right-corner" style="align-items:flex-end">
      <!-- attack button now LEFT of jump/crouch -->
      <div style="display:flex;gap:10px;align-items:flex-end">
        <button id="btnAttack" class="attack-circle" aria-label="Attack">
          <svg viewBox="0 0 24 24" width="34" height="34" fill="#fff"><path d="M3 21l18-9L3 3v7l12 2-12 2v7z"/></svg>
        </button>

        <div class="vert-stack" style="margin-bottom:6px">
          <button id="btnJump" class="corner-btn" aria-label="Jump">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M12 20V8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M6 14l6-6 6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <button id="btnCrouch" class="corner-btn" aria-label="Crouch">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M4 12h16" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M8 16h8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/></svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite">Game siap</div>

<script>
/* ================== FIXED + PROTECTIONS ==================
Implemented many animation & input protections requested.
Highlights:
- Force state transitions when an animation finishes (prevent stuck repeating attacks).
- setState(next, {force:true}) to override priority for end-of-animation resets.
- Input buffer for short inputs (e.g., tap jump slightly before landing).
- Anti-spam & button cooldowns, single-pointer capture, left/right conflict resolution.
- Min state durations, stuck-state watchdog, NaN safety, clamping, obstacle collision.
- Improved HP UI updates + color change depending on HP.

The code is structured & commented so you can tweak timings easily.
=========================================================== */

const byId = id => document.getElementById(id);
const toast = byId('toast');
function showToast(msg, t=1400){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), t); }

/* Prevent default mobile scroll */
window.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
window.addEventListener('contextmenu', e => e.preventDefault());

/* ORIENTATION / FULLSCREEN overlay */
const rotateOverlay = byId('rotateOverlay');
const btnFullLock = byId('btnFullLock'), btnDismiss = byId('btnDismiss');

function isPortrait(){ return window.innerHeight > window.innerWidth; }
function showOverlay(){ rotateOverlay.classList.remove('hidden'); rotateOverlay.style.display='flex'; }
function hideOverlay(){ rotateOverlay.classList.add('hidden'); rotateOverlay.style.display='none'; }

btnFullLock.addEventListener('click', ()=>{
  const el = document.documentElement;
  if(el.requestFullscreen) el.requestFullscreen().then(()=>{ try{ screen.orientation && screen.orientation.lock && screen.orientation.lock('landscape'); }catch(e){} });
  else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  setTimeout(()=>{ if(!isPortrait()) hideOverlay(); }, 600);
});
btnDismiss.addEventListener('click', ()=>{ if(!isPortrait()) hideOverlay(); else showToast('Silakan putar perangkat ke landscape'); });

window.addEventListener('resize', ()=>{ if(isPortrait()) showOverlay(); else hideOverlay();});
window.addEventListener('orientationchange', ()=> setTimeout(()=>{ if(isPortrait()) showOverlay(); else hideOverlay(); },250) );
if(isPortrait()) showOverlay(); else hideOverlay();

/* CANVAS SETUP */
const canvas = byId('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
let W = window.innerWidth, H = window.innerHeight;
function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

/* WORLD & OBSTACLES (for collision testing) */
let GROUND_Y = Math.round(H * 0.78);
const obstacles = [
  { x: 520, y: GROUND_Y - 80, w: 240, h: 16 },
  { x: 920, y: GROUND_Y - 150, w: 160, h: 16 },
];
window.addEventListener('resize', ()=>{ GROUND_Y = Math.round(window.innerHeight * 0.78); });

/* HERO */
const hero = {
  x: 180, y: GROUND_Y, vx:0, vy:0, dir:1,
  w:48, h:64,
  state:'idle', frame:0, frameTick:0, onGround:true, hp:100, stateSince:0,
  lastFrameChange: performance.now(), lastStateChange: performance.now()
};

/* ANIMATIONS */
const ANIMS = { 'idle':4,'idle-2':4,'run':6,'jump':4,'fall':2,'attack1':5,'attack2':6,'attack3':6,'hurt':3,'die':7,'crouch':4,'slide':2 };

/* Load sprites with robust fallback */
const SPRITES = {};
let totalToLoad = 0, loadedCount = 0;
for(const k in ANIMS){
  SPRITES[k] = [];
  for(let i=0;i<ANIMS[k];i++){
    totalToLoad++;
    const img = new Image();
    const fname = `asset/hero/adventurer-${k}-${String(i).padStart(2,'0')}.png`;
    img.onload = ()=> loadedCount++;
    img.onerror = ()=> { loadedCount++; console.warn('img load fail', fname); };
    img.src = fname;
    SPRITES[k].push(img);
  }
}

// Protection: wait for a minimum threshold or timeout
const SPRITE_MIN_THRESHOLD = Math.min(6, totalToLoad);
let spriteReady = false;
const spriteWaitStart = performance.now();
const SPRITE_WAIT_TIMEOUT = 1500;
(function waitSprites(){
  if(loadedCount >= SPRITE_MIN_THRESHOLD || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    spriteReady = true;
  } else setTimeout(waitSprites, 80);
})();

/* INPUT system with protections */
const INPUT = { left:false, right:false, jump:false, attack:false, crouch:false };
let activePointerId = null; // single pointer
let lastAttackAt = 0, lastJumpAt = 0; // cooldowns
const attackCooldownMs = 420, jumpCooldownMs = 220;
let queuedAction = null; // single queued action

// Input buffer: store taps up to 300ms to execute when possible
const inputBuffer = [];
const INPUT_BUFFER_TIME = 300;

// Button press timestamps to resolve left/right conflicts
let lastLeftAt = 0, lastRightAt = 0, lastDirAt = 0;

// Button anti-spam: track disable timers
const buttonCooldown = new Map();
function disableBtnFor(id, ms){ const el=byId(id); if(!el) return; el.disabled=true; buttonCooldown.set(id, performance.now()+ms); setTimeout(()=>{ if(performance.now()>=buttonCooldown.get(id)) { el.disabled=false; buttonCooldown.delete(id);} }, ms+10); }

// Protection 10: block inputs if overlay visible or sprites not ready
function inputAllowed(){ return spriteReady && rotateOverlay.classList.contains('hidden'); }

/* Unified pointer binding util */
function bindBtn(id, onDown, onUp, opts={cooldown:0}){
  const el = byId(id);
  if(!el) return;
  el.addEventListener('pointerdown', (ev)=>{
    if(!inputAllowed()) return;
    if(el.disabled) return;
    if(activePointerId !== null && activePointerId !== ev.pointerId) return; // ignore multi pointers
    activePointerId = ev.pointerId;
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    el.classList.add('pressed');
    if(opts.cooldown) disableBtnFor(id, opts.cooldown);
    try{ onDown(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointerup', (ev)=>{
    if(activePointerId !== ev.pointerId) return;
    el.releasePointerCapture && el.releasePointerCapture(ev.pointerId);
    activePointerId = null;
    el.classList.remove('pressed');
    try{ onUp(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointercancel', (ev)=>{ if(activePointerId === ev.pointerId){ activePointerId = null; el.classList.remove('pressed'); onUp(ev);} });
  el.addEventListener('pointerleave', (ev)=>{ if(activePointerId === ev.pointerId){ el.classList.remove('pressed'); }});
}

/* Left / Right with conflict resolution & anti-stuck */
bindBtn('btnLeft', ()=>{ if(!inputAllowed()) return; lastLeftAt = performance.now(); lastDirAt = lastLeftAt; INPUT.left = true; INPUT.right = false; }, ()=>{ INPUT.left = false; });
bindBtn('btnRight', ()=>{ if(!inputAllowed()) return; lastRightAt = performance.now(); lastDirAt = lastRightAt; INPUT.right = true; INPUT.left = false; }, ()=>{ INPUT.right = false; });

bindBtn('btnJump', ()=>{
  if(!inputAllowed()) return;
  const now = performance.now();
  if(now - lastJumpAt < jumpCooldownMs) return; // cooldown
  // if not allowed now (in air), buffer it
  if(!hero.onGround){ inputBuffer.push({type:'jump', t:now}); return; }
  lastJumpAt = now;
  INPUT.jump = true;
}, ()=>{ INPUT.jump = false; }, {cooldown:80});

bindBtn('btnAttack', ()=>{
  if(!inputAllowed()) return;
  const now = performance.now();
  if(now - lastAttackAt < attackCooldownMs) return;
  // only allow queued attack if not already in attack state
  if(hero.state && hero.state.startsWith('attack')) return;
  lastAttackAt = now;
  INPUT.attack = true; queuedAction = 'attack';
}, ()=>{ INPUT.attack = false; queuedAction = null; }, {cooldown:120});

bindBtn('btnCrouch', ()=>{ if(!inputAllowed()) return; INPUT.crouch = true; }, ()=>{ INPUT.crouch = false; });

/* Keyboard (desktop) - similar protections */
window.addEventListener('keydown', (e)=>{
  if(!inputAllowed()) return;
  if(e.repeat) return;
  if(e.key === 'ArrowLeft' || e.key === 'a'){ INPUT.left = true; INPUT.right = false; lastLeftAt = performance.now(); }
  if(e.key === 'ArrowRight' || e.key === 'd'){ INPUT.right = true; INPUT.left = false; lastRightAt = performance.now(); }
  if((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') ){
    const now = performance.now(); if(now - lastJumpAt > jumpCooldownMs){ lastJumpAt = now; if(hero.onGround) INPUT.jump = true; else inputBuffer.push({type:'jump', t:now}); }
  }
  if(e.key === 'j' || e.key === 'k'){
    const now=performance.now(); if(now - lastAttackAt > attackCooldownMs && !hero.state.startsWith('attack')){ lastAttackAt=now; INPUT.attack=true; queuedAction='attack'; }
  }
  if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = true;
});
window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = false;
  if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = false;
  if(e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') INPUT.jump = false;
});

/* PROTECTION 5: clamp velocities */
const VX_MAX = 12, VY_MAX = 40, VY_MIN = -28;

/* PROTECTION 6: min state durations (ms) */
const MIN_STATE_DUR = { 'attack1': 300, 'attack2': 300, 'attack3':300, 'hurt': 400, 'die': 99999, 'jump': 180, 'fall': 120 };

/* PRIORITY but allow force */
const PRIORITY = { die:90, hurt:80, attack1:70, attack2:70, attack3:70, jump:60, fall:50, crouch:40, run:30, idle:10 };
function canChangeState(curr, next, opts={force:false}){
  if(curr === next) return false;
  if(curr === 'die' && !opts.force) return false;
  const now = performance.now();
  if(MIN_STATE_DUR[curr] && now - hero.stateSince < MIN_STATE_DUR[curr] && !opts.force) return false;
  const curP = PRIORITY[curr] || 0, nextP = PRIORITY[next] || 0;
  if(nextP < curP && !opts.force) return false;
  return true;
}

function setState(next, opts={force:false}){
  const curr=hero.state;
  if(!canChangeState(curr,next,opts)) return false;
  hero.state = next; hero.frame = 0; hero.frameTick = 0; hero.stateSince = performance.now(); hero.lastStateChange = performance.now();
  hero.lastFrameChange = performance.now();
  return true;
}

/* Helper to force next state when animation finishes (no priority blocking) */
function forceState(next){ return setState(next, {force:true}); }

/* SAFETY helpers */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function safeNumber(v,def=0){ return (isFinite(v) && !isNaN(v)) ? v : def; }

/* Collision helpers (AABB) */
function rectOfHero(){ return { x: hero.x - hero.w/2, y: hero.y - hero.h, w: hero.w, h: hero.h }; }
function rectOverlap(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }
function resolveAABBCollision(h, obs){
  const overlapX = Math.min(h.x + h.w - obs.x, obs.x + obs.w - h.x);
  const overlapY = Math.min(h.y + h.h - obs.y, obs.y + obs.h - h.y);
  if(overlapX <= 0 || overlapY <= 0) return false;
  if(overlapX < overlapY){
    if(h.x + h.w/2 < obs.x + obs.w/2){ hero.x -= overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1); } else { hero.x += overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1); }
    return true;
  } else {
    if(h.y + h.h/2 < obs.y + obs.h/2){ hero.y -= overlapY + 0.5; hero.vy = 0; hero.onGround = true; } else { hero.y += overlapY + 0.5; hero.vy = Math.max(hero.vy, 0); }
    return true;
  }
}

/* Input buffer consumer */
function consumeBuffer(){
  const now = performance.now();
  while(inputBuffer.length){
    const it = inputBuffer.shift();
    if(now - it.t > INPUT_BUFFER_TIME) continue; // expired
    if(it.type === 'jump' && hero.onGround){ hero.vy = -13.2; hero.onGround = false; setState('jump'); break; }
  }
}

/* main update loop (with try/catch) */
let last = performance.now();
function update(dt){
  try {
    // NaN safety
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);
    hero.vx = safeNumber(hero.vx, 0); hero.vy = safeNumber(hero.vy, 0);

    // remember previous onGround to detect landing
    const prevOnGround = hero.onGround;

    // consume input buffer first
    consumeBuffer();

    // pause inputs until sprite ready
    if(!spriteReady){ hero.vx *= 0.8; hero.vy += 0.6; }
    else {
      // Attack takes precedence but must finish; disallow starting attack in mid-air (unless you want)
      if(INPUT.attack && hero.onGround && !hero.state.startsWith('attack')){
        if(performance.now() - hero.stateSince > 40){ setState('attack1'); queuedAction = null; INPUT.attack = false; }
      } else if(!hero.onGround){
        // while airborne, choose jump or fall and DO NOT auto-switch to run until you land
        if(hero.vy < -1) setState('jump'); else setState('fall');
      } else if(INPUT.crouch){ setState('crouch'); }
      else if(INPUT.left || INPUT.right){
        // resolve both pressed: choose most recent direction
        if(INPUT.left && INPUT.right){
          if(lastLeftAt > lastRightAt) hero.dir = -1; else hero.dir = 1;
        } else hero.dir = INPUT.right ? 1 : -1;
        setState('run');
        hero.vx += (INPUT.right ? 1 : -1) * 1.2; // stronger acceleration for snappier control
      } else {
        // no movement input: reduce vx smoothly and return to idle if on ground
        hero.vx *= 0.82;
        if(hero.onGround) setState('idle');
      }

      // jump consumption (single impulse)
      if(INPUT.jump && hero.onGround){ hero.vy = -13.2; hero.onGround = false; setState('jump'); INPUT.jump = false; }
    }

    // physics
    hero.vy += 0.66;
    hero.vx = clamp(hero.vx, -VX_MAX, VX_MAX);
    hero.vy = clamp(hero.vy, VY_MIN, VY_MAX);

    hero.x += hero.vx; hero.y += hero.vy;

    // base ground & landing behavior
    if(hero.y >= GROUND_Y){
      if(!prevOnGround && Math.abs(hero.vy) > 18){ hero.hp = clamp(hero.hp - 8, 0, 100); setState('hurt'); }
      // clamp to ground
      hero.y = GROUND_Y; hero.vy = 0;
      // detect landing event
      if(!prevOnGround){
        hero.onGround = true;
        // NEW: after landing, decide animation based on current input
        // If player is holding run (left/right) -> go to run, else -> idle
        if(INPUT.left || INPUT.right){
          forceState('run');
        } else {
          forceState('idle');
        }
      } else {
        hero.onGround = true;
      }
    } else {
      hero.onGround = false;
    }

    // obstacle collisions
    const hRect = rectOfHero();
    for(const obs of obstacles){ if(rectOverlap(hRect, obs)) resolveAABBCollision(hRect, obs); }

    // clamp hero inside world bounds
    hero.x = clamp(hero.x, 32, Math.max(600, W - 32));

    // animation tick & protections against stuck repeating
    hero.frameTick += Math.max(1, Math.floor(dt / 16));
    const animMeta = ANIMS[hero.state] || ANIMS['idle'];
    const ticksPerFrame = (hero.state === 'run' ? 4 : (hero.state.startsWith('attack') ? 6 : 8));
    if(hero.frameTick >= ticksPerFrame){
      hero.frameTick = 0;
      const prevFrame = hero.frame;
      hero.frame++;
      hero.lastFrameChange = performance.now();

      // when frame reaches end
      if(hero.frame >= animMeta){
        const nonLooping = !['idle','run','fall','crouch'].includes(hero.state);
        if(!animMeta || animMeta <= 0) hero.frame = 0; else {
          if(!nonLooping){ hero.frame = hero.frame % animMeta; }
          else {
            // finished a non-looping animation -> go to appropriate next (force)
            // Prefer movement if input held
            if(INPUT.left || INPUT.right) forceState('run');
            else forceState('idle');
            hero.frame = 0;
          }
        }
      }
    }

    // stuck-state watchdog: if state hasn't changed frames in a long time, reset to idle
    if(performance.now() - hero.lastFrameChange > 2500){ console.warn('frame stalled, forcing idle'); forceState('idle'); }

    // queuedAction cleanup
    if(queuedAction && queuedAction === 'attack' && !hero.state.startsWith('attack')) queuedAction = null;

    // sanitize numbers
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);

  } catch(err){
    console.error('update error', err);
    hero.vx = 0; hero.vy = 0; hero.state = 'idle'; hero.frame = 0; hero.frameTick = 0; hero.hp = clamp(hero.hp,0,100);
  }
}
    else {
      // Attack takes precedence but must finish; disallow starting attack in mid-air (unless you want)
      if(INPUT.attack && hero.onGround && !hero.state.startsWith('attack')){
        if(performance.now() - hero.stateSince > 40){ setState('attack1'); queuedAction = null; INPUT.attack = false; }
      } else if(!hero.onGround){
        if(hero.vy < -1) setState('jump'); else setState('fall');
      } else if(INPUT.crouch){ setState('crouch'); }
      else if(INPUT.left || INPUT.right){
        // resolve both pressed: choose most recent direction
        if(INPUT.left && INPUT.right){
          if(lastLeftAt > lastRightAt) hero.dir = -1; else hero.dir = 1;
        } else hero.dir = INPUT.right ? 1 : -1;
        setState('run');
        hero.vx += (INPUT.right ? 1 : -1) * 1.2; // stronger acceleration for snappier control
      } else {
        // no movement input: reduce vx smoothly and return to idle if on ground
        hero.vx *= 0.82;
        if(hero.onGround) setState('idle');
      }

      // jump consumption (single impulse)
      if(INPUT.jump && hero.onGround){ hero.vy = -13.2; hero.onGround = false; setState('jump'); INPUT.jump = false; }
    }

    // physics
    hero.vy += 0.66;
    hero.vx = clamp(hero.vx, -VX_MAX, VX_MAX);
    hero.vy = clamp(hero.vy, VY_MIN, VY_MAX);

    hero.x += hero.vx; hero.y += hero.vy;

    // base ground
    if(hero.y >= GROUND_Y){
      if(!hero.onGround && Math.abs(hero.vy) > 18){ hero.hp = clamp(hero.hp - 8, 0, 100); setState('hurt'); }
      hero.y = GROUND_Y; hero.vy = 0; hero.onGround = true;
    } else hero.onGround = false;

    // obstacle collisions
    const hRect = rectOfHero();
    for(const obs of obstacles){ if(rectOverlap(hRect, obs)) resolveAABBCollision(hRect, obs); }

    // clamp hero inside world bounds
    hero.x = clamp(hero.x, 32, Math.max(600, W - 32));

    // animation tick & protections against stuck repeating
    hero.frameTick += Math.max(1, Math.floor(dt / 16));
    const animMeta = ANIMS[hero.state] || ANIMS['idle'];
    const ticksPerFrame = (hero.state === 'run' ? 4 : (hero.state.startsWith('attack') ? 6 : 8));
    if(hero.frameTick >= ticksPerFrame){
      hero.frameTick = 0;
      const prevFrame = hero.frame;
      hero.frame++;
      hero.lastFrameChange = performance.now();

      // when frame reaches end
      if(hero.frame >= animMeta){
        const nonLooping = !['idle','run','fall','crouch'].includes(hero.state);
        if(!animMeta || animMeta <= 0) hero.frame = 0; else {
          if(!nonLooping){ hero.frame = hero.frame % animMeta; }
          else {
            // finished a non-looping animation -> go to appropriate next (force)
            // Prefer movement if input held
            if(INPUT.left || INPUT.right) forceState('run');
            else forceState('idle');
            hero.frame = 0;
          }
        }
      }
    }

    // stuck-state watchdog: if state hasn't changed frames in a long time, reset to idle
    if(performance.now() - hero.lastFrameChange > 2500){ console.warn('frame stalled, forcing idle'); forceState('idle'); }

    // queuedAction cleanup
    if(queuedAction && queuedAction === 'attack' && !hero.state.startsWith('attack')) queuedAction = null;

    // sanitize numbers
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);

  } catch(err){
    console.error('update error', err);
    hero.vx = 0; hero.vy = 0; hero.state = 'idle'; hero.frame = 0; hero.frameTick = 0; hero.hp = clamp(hero.hp,0,100);
  }
}

/* DRAW */
function draw(){
  try {
    ctx.clearRect(0,0,W,H);
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#242628'); g.addColorStop(1,'#101214');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // obstacles
    for(const obs of obstacles){ ctx.fillStyle = '#2b2c2f'; ctx.fillRect(obs.x, obs.y, obs.w, obs.h); ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.strokeRect(obs.x, obs.y, obs.w, obs.h); }

    // hero draw (fallback rectangle if images missing)
    const animSet = SPRITES[hero.state] && SPRITES[hero.state].length ? SPRITES[hero.state] : (SPRITES['idle'] || []);
    const frameIndex = hero.frame % (animSet.length || 1);
    const img = animSet[frameIndex] || null;
    if(img && img.complete && img.naturalWidth){
      const scale = Math.max(1.2, Math.min(2.1, (H/720) * 1.8));
      const w = img.width * scale, h = img.height * scale;
      ctx.save(); ctx.translate(hero.x, hero.y); ctx.scale(hero.dir,1);
      try { ctx.drawImage(img, -w/2, -h, w, h); } catch(e){ ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h); }
      ctx.restore();
    } else {
      ctx.save(); ctx.translate(hero.x, hero.y); ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h); ctx.restore();
    }

    // HUD overlay shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0,0,W,48);

  } catch(err){ console.error('draw error', err); }
}

/* GAME LOOP */
let lastT = performance.now();
function loop(now){ try{ const dt = now - lastT; lastT = now; update(dt); draw(); } catch(e){ console.error('main loop error', e); } requestAnimationFrame(loop); }

// start when ready
(function startWhenReady(){ if(spriteReady || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){ lastT = performance.now(); requestAnimationFrame(loop); showToast('Siap! Gunakan kontrol pojok untuk main'); } else setTimeout(startWhenReady, 80); })();

/* HP UI update */
function updateHpUI(){ const hb = byId('hpFill'); const ht = byId('hpText'); if(hb && ht){ hb.style.width = hero.hp + '%'; ht.textContent = hero.hp + '%'; if(hero.hp > 60) hb.style.background = 'linear-gradient(90deg,var(--hp-green),#10b981)'; else if(hero.hp > 30) hb.style.background = 'linear-gradient(90deg,var(--hp-yellow),#f97316)'; else hb.style.background = 'linear-gradient(90deg,var(--hp-red),#ef4444)'; } }
setInterval(updateHpUI, 120);

/* protection: remove obvious watermarks */
setTimeout(()=>{ Array.from(document.querySelectorAll('img,div')).forEach(el=>{ try{ if(el.innerText && /apkpure/i.test(el.innerText)) el.remove(); if(el.src && typeof el.src === 'string' && /apkpure/i.test(el.src)) el.remove(); }catch(e){} }); }, 900);

/* safety: clear inputs when tab hidden */
document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ INPUT.left = INPUT.right = INPUT.attack = INPUT.jump = INPUT.crouch = false; } });

/* desktop hint */
if(window.innerWidth > 900) setTimeout(()=> showToast('Gunakan A/D atau Panah ← → untuk bergerak, Space untuk lompat, J untuk serang'), 1200);
</script>
</body>
</html>
