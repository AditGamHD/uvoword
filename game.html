<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="theme-color" content="#141516">
<title>UvoWorld</title>
<style>
  :root{
    --bg:#0f1113; --panel:#1d1f22; --accent:#0b84ff; --muted:#9aa0a6;
    --btn-size:72px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;width:100%;margin:0;padding:0;overflow:hidden;background:var(--bg);color:#fff;font-family:Inter,system-ui,Arial;}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#202226,#121315)}
  /* Overlay rotate */
  #rotateOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;background:rgba(3,3,4,0.94);padding:20px;text-align:center}
  #rotateOverlay.hidden{display:none}
  .rotate-box{background:linear-gradient(180deg,#0c0d0e,#121314);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);max-width:420px}
  .rotate-title{font-weight:700;font-size:18px;margin-bottom:8px}
  .rotate-desc{color:var(--muted);margin-bottom:12px;font-size:14px}
  .btn{padding:10px 14px;border-radius:10px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  /* HUD top */
  .hud{position:fixed;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:800;pointer-events:none}
  .hp-box{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#161718);padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:center}
  .hp-bar{width:160px;height:18px;background:#232425;border-radius:10px;overflow:hidden}
  .hp-fill{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#ff2b2b);transition:width .32s}
  .menu{pointer-events:auto;background:linear-gradient(180deg,#1b1c1e,#141516);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
  /* Controls bottom corners */
  .controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:space-between;align-items:end;padding:0 12px;z-index:900;pointer-events:none}
  .left-corner,.right-corner{pointer-events:auto;display:flex;gap:10px;align-items:center}
  .corner-btn{width:var(--btn-size);height:var(--btn-size);border-radius:12px;background:linear-gradient(180deg,#17181a,#232426);border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .attack-circle{width:86px;height:86px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#0569d6);display:flex;align-items:center;justify-content:center;border:2px solid rgba(0,0,0,0.2);cursor:pointer;box-shadow:0 12px 30px rgba(11,132,255,0.14)}
  .vert-stack{display:flex;flex-direction:column;gap:12px}
  .pressed{transform:translateY(2px) scale(.98);opacity:.96}
  /* toast */
  #toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:var(--accent);padding:8px 14px;border-radius:8px;color:#fff;z-index:1200;opacity:0;transition:opacity .25s}
  #toast.show{opacity:1}
  @media (max-width:700px){:root{--btn-size:60px}.attack-circle{width:70px;height:70px}}
  /* nickname above hero */
  .nickname{position:absolute;font-size:14px;padding:2px 8px;border-radius:6px;background:rgba(0,0,0,0.6);pointer-events:none}
</style>
</head>
<body>
  <div id="gameWrap"><canvas id="gameCanvas" width="1280" height="720"></canvas></div>

  <!-- ROTATE / FULLSCREEN OVERLAY -->
  <div id="rotateOverlay">
    <div class="rotate-box">
      <div class="rotate-title">Mohon Rotasi Device Anda</div>
      <div class="rotate-desc">Aktifkan fullscreen lalu putar perangkat ke <strong>landscape</strong>. Game butuh orientasi landscape untuk kontrol optimal.</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="btnFullLock" class="btn">Aktifkan Fullscreen & Lock</button>
        <button id="btnDismiss" class="btn ghost">Saya Sudah</button>
      </div>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud">
    <div class="hp-box" aria-hidden="false"><svg width="18" height="18" viewBox="0 0 24 24" style="opacity:.95"><path d="M12 21s-8-4.5-8-11a5 5 0 0 1 10 0 5 5 0 0 1 10 0c0 6.5-8 11-8 11z" fill="#ff6b6b"/></svg><div style="font-size:13px;color:var(--muted)">HP</div><div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div></div>
    <div class="menu">Menu</div>
  </div>

  <!-- CONTROLS: left corner arrows; right corner cluster attack-left, (vertical jump & crouch) -->
  <div class="controls">
    <div class="left-corner">
      <button id="btnLeft" class="corner-btn" aria-label="Left">
        <!-- left icon -->
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M15 6L9 12l6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <button id="btnRight" class="corner-btn" aria-label="Right">
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none"><path d="M9 6l6 6-6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
    </div>

    <div style="flex:1"></div>

    <div class="right-corner" style="align-items:flex-end">
      <!-- attack button now LEFT of jump/crouch -->
      <div style="display:flex;gap:10px;align-items:flex-end">
        <button id="btnAttack" class="attack-circle" aria-label="Attack">
          <svg viewBox="0 0 24 24" width="34" height="34" fill="#fff"><path d="M3 21l18-9L3 3v7l12 2-12 2v7z"/></svg>
        </button>

        <div class="vert-stack" style="margin-bottom:6px">
          <button id="btnJump" class="corner-btn" aria-label="Jump">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M12 20V8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M6 14l6-6 6 6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <button id="btnCrouch" class="corner-btn" aria-label="Crouch">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none"><path d="M4 12h16" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/><path d="M8 16h8" stroke="#fff" stroke-width="1.8" stroke-linecap="round"/></svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite">Game siap</div>

  <!-- Firebase compat SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
/* ================== MULTIPLAYER + UTILITIES ==================
  - Simple user system: username stored in localStorage (set by index.html / lobby.html)
  - Realtime sync: /players/{username}
  - Each client writes its own state and listens for changes to render other players.
  - WARNING: passwords are handled on index.html; here we ONLY read localStorage username.
=========================================================== */

const firebaseConfig = { databaseURL: "https://uvoword-default-rtdb.asia-southeast1.firebasedatabase.app" };
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

const byId = id => document.getElementById(id);
const toast = byId('toast');
function showToast(msg, t=1400){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), t); }

const username = localStorage.getItem('uvo_user');
if(!username) {
  alert('Tidak ada sesi. Silakan login terlebih dahulu.'); location.href = 'index.html';
  throw new Error('not logged in');
}

/* --- Multiplayer state --- */
const playersRef = db.ref('players');
let otherPlayers = {}; // { username: {x,y,dir,state,hp,coin,lastSeen} }
let myPlayerRef = db.ref('players/' + username);
let syncInterval = null;

/* basic presence: remove on disconnect */
myPlayerRef.onDisconnect().remove().catch(()=>{ /* ignore */ });

/* subscribe to players list */
playersRef.on('value', snap=>{
  const val = snap.val() || {};
  // update otherPlayers object (exclude self)
  otherPlayers = {};
  for(const k in val){
    if(k === username) continue;
    otherPlayers[k] = val[k];
  }
});

/* --- existing game code adapted to multiplayer --- */

/* Prevent default mobile scroll */
window.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
window.addEventListener('contextmenu', e => e.preventDefault());

/* ORIENTATION / FULLSCREEN overlay */
const rotateOverlay = byId('rotateOverlay');
const btnFullLock = byId('btnFullLock'), btnDismiss = byId('btnDismiss');
function isPortrait(){ return window.innerHeight > window.innerWidth; }
function showOverlay(){ rotateOverlay.classList.remove('hidden'); rotateOverlay.style.display='flex'; }
function hideOverlay(){ rotateOverlay.classList.add('hidden'); rotateOverlay.style.display='none'; }
btnFullLock.addEventListener('click', ()=>{ const el = document.documentElement; if(el.requestFullscreen) el.requestFullscreen().then(()=>{ try{ screen.orientation && screen.orientation.lock && screen.orientation.lock('landscape'); }catch(e){} }); else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen(); setTimeout(()=>{ if(!isPortrait()) hideOverlay(); }, 600); });
btnDismiss.addEventListener('click', ()=>{ if(!isPortrait()) hideOverlay(); else showToast('Silakan putar perangkat ke landscape'); });
window.addEventListener('resize', ()=>{ if(isPortrait()) showOverlay(); else hideOverlay();});
window.addEventListener('orientationchange', ()=> setTimeout(()=>{ if(isPortrait()) showOverlay(); else hideOverlay(); },250) );
if(isPortrait()) showOverlay(); else hideOverlay();

/* CANVAS SETUP */
const canvas = byId('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
let W = window.innerWidth, H = window.innerHeight;
function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

/* WORLD & OBSTACLES */
const GROUND_Y = Math.round(H * 0.78);
const obstacles = [
  { x: 520, y: GROUND_Y - 80, w: 240, h: 16 },
  { x: 920, y: GROUND_Y - 150, w: 160, h: 16 },
];

/* LOCAL HERO (this client) */
const hero = {
  x: 180, y: GROUND_Y, vx:0, vy:0, dir:1,
  w:48, h:64,
  state:'idle', frame:0, frameTick:0, onGround:true,
  hp:100, stateSince:0,
  stateLock:false,
  attackStage:0, nextAttackQueued:false,
  prevOnGround:true
};

/* ANIMS & SPRITES (kept as-is) */
const ANIMS = {
  'idle':4,'idle-2':4,'run':6,'jump':4,'fall':2,'attack1':5,'attack2':6,'attack3':6,
  'hurt':3,'die':7,'crouch':4,'slide':2,'smrslt':4,'crnr-clmb':5,'crnr-jmp':3,'crnr-grab':2
};
const SPRITES = {};
let totalToLoad = 0, loadedCount = 0;
for(const k in ANIMS){
  SPRITES[k] = [];
  for(let i=0;i<ANIMS[k];i++){
    totalToLoad++;
    const img = new Image();
    const fname = `asset/hero/adventurer-${k}-${String(i).padStart(2,'0')}.png`;
    img.onload = ()=> loadedCount++;
    img.onerror = ()=> { loadedCount++; console.warn('img load fail', fname); };
    img.src = fname;
    SPRITES[k].push(img);
  }
}
const SPRITE_MIN_THRESHOLD = Math.min(8, totalToLoad);
let spriteReady = false;
const spriteWaitStart = performance.now();
const SPRITE_WAIT_TIMEOUT = 2000;
(function waitSprites(){
  if(loadedCount >= SPRITE_MIN_THRESHOLD || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    spriteReady = true;
  } else setTimeout(waitSprites, 80);
})();

/* INPUT system */
const INPUT = { left:false, right:false, jump:false, attack:false, crouch:false, up:false };
let activePointerId = null;
let lastAttackAt = 0, lastJumpAt = 0;
const attackCooldownMs = 120, jumpCooldownMs = 120;
let queuedAction = null;
function inputAllowed(){ return spriteReady && rotateOverlay.classList.contains('hidden'); }

/* pointer binding util */
function bindBtn(id, onDown, onUp){
  const el = byId(id);
  if(!el) return;
  el.addEventListener('pointerdown', (ev)=>{
    if(!inputAllowed()) return;
    if(activePointerId !== null && activePointerId !== ev.pointerId) return;
    activePointerId = ev.pointerId;
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    el.classList.add('pressed');
    try{ onDown(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointerup', (ev)=>{
    if(activePointerId !== ev.pointerId) return;
    el.releasePointerCapture && el.releasePointerCapture(ev.pointerId);
    activePointerId = null; el.classList.remove('pressed'); try{ onUp(ev); }catch(e){ console.error(e); }
  });
  el.addEventListener('pointercancel', (ev)=>{ if(activePointerId === ev.pointerId){ activePointerId = null; el.classList.remove('pressed'); onUp(ev);} });
  el.addEventListener('pointerleave', (ev)=>{ if(activePointerId === ev.pointerId){ el.classList.remove('pressed'); }});
}
bindBtn('btnLeft', ()=>INPUT.left=true, ()=>INPUT.left=false);
bindBtn('btnRight', ()=>INPUT.right=true, ()=>INPUT.right=false);
bindBtn('btnJump', ()=>{ if(!inputAllowed()) return; const now = performance.now(); if(now - lastJumpAt < jumpCooldownMs) return; lastJumpAt = now; INPUT.jump = true; }, ()=>{ INPUT.jump = false; });
bindBtn('btnAttack', ()=>{ if(!inputAllowed()) return; const now = performance.now(); if(now - lastAttackAt < attackCooldownMs) return; lastAttackAt = now; INPUT.attack = true; queuedAction = 'attack'; }, ()=>{ INPUT.attack = false; queuedAction = null; });
bindBtn('btnCrouch', ()=>INPUT.crouch = true, ()=>INPUT.crouch = false);

window.addEventListener('keydown', (e)=>{ if(!inputAllowed()) return; if(e.repeat) return; if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = true; if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = true; if(e.key === 'ArrowUp' || e.key === 'w') INPUT.up = true; if((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && (performance.now() - lastJumpAt > jumpCooldownMs)){ lastJumpAt = performance.now(); INPUT.jump = true; } if(e.key === 'j' || e.key === 'k'){ if(performance.now() - lastAttackAt > attackCooldownMs){ lastAttackAt = performance.now(); INPUT.attack = true; queuedAction='attack'; } } if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = true; });
window.addEventListener('keyup', (e)=>{ if(e.key === 'ArrowLeft' || e.key === 'a') INPUT.left = false; if(e.key === 'ArrowRight' || e.key === 'd') INPUT.right = false; if(e.key === 'ArrowUp' || e.key === 'w') INPUT.up = false; if(e.key === 's' || e.key === 'ArrowDown') INPUT.crouch = false; if(e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') INPUT.jump = false; });

/* physics and protections */
const VX_MAX = 12, VY_MAX = 40, VY_MIN = -28;
const MIN_STATE_DUR = { 'attack1': 140, 'attack2': 140, 'attack3':140, 'hurt': 350, 'die': 99999, 'jump': 120, 'fall': 100, 'slide': 220, 'crnr-grab': 120 };
const LOOP_STATES = new Set(['idle','run','fall','crouch','idle-2']);
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function safeNumber(v,def=0){ return (isFinite(v) && !isNaN(v)) ? v : def; }

/* collision helpers */
function rectOfHero(h = hero){
  return { x: h.x - h.w/2, y: h.y - h.h, w: h.w, h: h.h };
}
function rectOverlap(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }
function resolveAABBCollision(hRect, obs){
  const overlapX = Math.min(hRect.x + hRect.w - obs.x, obs.x + obs.w - hRect.x);
  const overlapY = Math.min(hRect.y + hRect.h - obs.y, obs.y + obs.h - hRect.y);
  if(overlapX <= 0 || overlapY <= 0) return false;
  if(overlapX < overlapY){
    if(hRect.x + hRect.w/2 < obs.x + obs.w/2){
      hero.x -= overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1);
    } else {
      hero.x += overlapX + 0.5; hero.vx = clamp(hero.vx, -1, 1);
    }
    return true;
  } else {
    if(hRect.y + hRect.h/2 < obs.y + obs.h/2){
      hero.y -= overlapY + 0.5; hero.vy = 0; hero.onGround = true;
    } else {
      hero.y += overlapY + 0.5; hero.vy = Math.max(hero.vy, 0);
    }
    return true;
  }
}

/* state machine (same as your original) */
function canChangeState(next, force=false){ if(hero.state === next) return false; if(hero.state === 'die' && next !== 'die') return false; if(hero.stateLock && !force) return false; return true; }
function setState(next, opts = {force:false, lock:false}){ const now = performance.now(); if(!opts.force && MIN_STATE_DUR[hero.state] && now - hero.stateSince < MIN_STATE_DUR[hero.state]) return false; if(!canChangeState(next, !!opts.force)) return false; hero.state = next; hero.frame = 0; hero.frameTick = 0; hero.stateSince = now; hero.stateLock = !!opts.lock; return true; }
function forceState(next){ return setState(next, {force:true, lock:false}); }
function startAttack(stage){ stage = Math.max(1, Math.min(3, stage)); hero.attackStage = stage; hero.nextAttackQueued = false; setState('attack' + stage, {force:true, lock:true}); }
function findNearbyEdge(){ const margin = 18; const topTolerance = 10; const heroFeetX = hero.x; for(const obs of obstacles){ const topY = obs.y; if(Math.abs((hero.y) - topY) <= topTolerance){ if(Math.abs(heroFeetX - obs.x) <= margin) return {obs, side:'left'}; if(Math.abs(heroFeetX - (obs.x + obs.w)) <= margin) return {obs, side:'right'}; } } return null; }
let lastAttackJumpTogether = 0;

/* update & draw (adapted to write/read DB) */
let lastT = performance.now();
function update(dt){
  try {
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);
    hero.vx = safeNumber(hero.vx, 0); hero.vy = safeNumber(hero.vy, 0);

    if(!spriteReady){
      hero.vx *= 0.8; hero.vy += 0.6;
    } else {
      if(INPUT.attack && INPUT.jump){
        const now = performance.now();
        if(now - lastAttackJumpTogether > 300){ lastAttackJumpTogether = now; }
        if(hero.onGround && canChangeState('smrslt')){ setState('smrslt', {force:true, lock:true}); hero.vy = -10; hero.onGround = false; }
      }
      if(!hero.onGround){
        if(INPUT.attack && canChangeState('attack1') && !hero.stateLock){ startAttack(1); } else { if(hero.vy > 1 && hero.state !== 'fall') setState('fall', {force:true, lock:false}); }
      } else {
        if(INPUT.attack && !hero.stateLock && (performance.now() - hero.stateSince > 40)) { startAttack(1); }
        else if(INPUT.attack && hero.state && hero.state.startsWith('attack') && hero.stateLock){ if(hero.attackStage > 0 && hero.attackStage < 3) { hero.nextAttackQueued = true; } }
        if(INPUT.crouch && (INPUT.left || INPUT.right) && hero.onGround && !hero.stateLock){
          if(setState('slide', {force:true, lock:true})){ hero.vx = (INPUT.right ? 6 : -6); }
        } else if(INPUT.crouch && !INPUT.left && !INPUT.right && hero.onGround && !hero.stateLock){
          setState('crouch', {force:true, lock:false}); hero.vx *= 0.6;
        }
        const edge = findNearbyEdge();
        if(edge && INPUT.up && hero.onGround && !hero.stateLock){ setState('crnr-grab', {force:true, lock:true}); }
        if(INPUT.jump && hero.onGround && !hero.stateLock){ hero.vy = -13.2; hero.onGround = false; setState('jump', {force:true, lock:false}); INPUT.jump = false; }
        if(!hero.stateLock){
          if(INPUT.left || INPUT.right){ hero.dir = INPUT.right ? 1 : -1; setState('run', {force:false, lock:false}); hero.vx += (INPUT.right ? 1 : -1) * 0.9; } else { setState('idle', {force:false, lock:false}); hero.vx *= 0.78; }
        }
      }
    }

    hero.vy += 0.66;
    hero.vx = clamp(hero.vx, -VX_MAX, VX_MAX);
    hero.vy = clamp(hero.vy, VY_MIN, VY_MAX);
    if(hero.onGround && !INPUT.left && !INPUT.right && !hero.stateLock){ hero.vx *= 0.7; }
    hero.x += hero.vx; hero.y += hero.vy;

    const wasOnGround = hero.onGround;
    if(hero.y >= GROUND_Y){
      if(!wasOnGround && Math.abs(hero.vy) > 18){ hero.hp = clamp(hero.hp - 8, 0, 100); setState('hurt', {force:true, lock:true}); }
      hero.y = GROUND_Y; hero.vy = 0; hero.onGround = true;
    } else hero.onGround = false;

    // obstacle collisions
    const hRect = rectOfHero();
    for(const obs of obstacles){ if(rectOverlap(hRect, obs)) { resolveAABBCollision(hRect, obs); } }

    if(!wasOnGround && hero.onGround){
      hero.stateLock = hero.state === 'die' || hero.state === 'hurt';
      if(hero.state === 'smrslt' || hero.state === 'jump' || hero.state === 'fall'){
        if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle');
      }
    }

    if(hero.state === 'crnr-grab' && hero.stateLock){ if(INPUT.up){ setState('crnr-clmb', {force:true, lock:true}); } }
    if(hero.state === 'crnr-clmb'){ const edge = findNearbyEdge(); if(edge){ hero.y = edge.obs.y; if(edge.side === 'left') hero.x = edge.obs.x + 20; else hero.x = edge.obs.x + edge.obs.w - 20; } hero.stateLock = false; if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); }

    hero.x = clamp(hero.x, 32, Math.max(600, W - 32));

    hero.frameTick += Math.max(1, Math.floor(dt / 16));
    const animMeta = ANIMS[hero.state] || ANIMS['idle'];
    const ticksPerFrame = (hero.state === 'run' ? 4 : (hero.state.startsWith('attack') ? 6 : 8));
    if(hero.frameTick >= ticksPerFrame){ hero.frameTick = 0; hero.frame++; if(hero.frame >= animMeta){ handleAnimationComplete(hero.state); } }

    if(queuedAction && queuedAction === 'attack' && !INPUT.attack) queuedAction = null;
    hero.x = safeNumber(hero.x, 200); hero.y = safeNumber(hero.y, GROUND_Y);

    // --- WRITE my player to Firebase (throttled elsewhere) ---
  } catch(err){
    console.error('update error', err);
    hero.vx = 0; hero.vy = 0; hero.state = 'idle'; hero.frame = 0; hero.stateLock = false;
  }
}

function handleAnimationComplete(stateEnded){
  if(LOOP_STATES.has(stateEnded)){ hero.frame = hero.frame % (ANIMS[stateEnded] || 1); return; }
  if(stateEnded.startsWith('attack')){
    if(hero.nextAttackQueued && hero.attackStage < 3){ startAttack(hero.attackStage + 1); return; } else { hero.attackStage = 0; hero.nextAttackQueued = false; hero.stateLock = false; if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); return; }
  }
  if(stateEnded === 'slide'){ hero.stateLock = false; hero.vx = 0; if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); return; }
  if(stateEnded === 'crouch'){ if(INPUT.crouch) { hero.frame = 0; return; } else { hero.stateLock = false; if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); return; } }
  if(stateEnded === 'jump' || stateEnded === 'smrslt' || stateEnded === 'fall'){ hero.stateLock = false; if(hero.onGround){ if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); } else { forceState('fall'); } return; }
  if(stateEnded === 'crnr-grab'){ hero.frame = 0; return; }
  if(stateEnded === 'crnr-clmb'){ const edge = findNearbyEdge(); if(edge){ hero.y = edge.obs.y; if(edge.side === 'left') hero.x = edge.obs.x + 20; else hero.x = edge.obs.x + edge.obs.w - 20; } hero.stateLock = false; if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); return; }
  if(stateEnded === 'hurt'){ hero.stateLock = false; if(hero.hp <= 0) { setState('die', {force:true, lock:true}); return; } if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); return; }
  if(stateEnded === 'die'){ hero.stateLock = true; return; }
  if(hero.onGround){ if(INPUT.left || INPUT.right) forceState('run'); else forceState('idle'); } else { forceState('fall'); }
}

/* DRAW including other players */
function draw(){
  try {
    ctx.clearRect(0,0,W,H);
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#242628'); g.addColorStop(1,'#101214');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    for(const obs of obstacles){
      ctx.fillStyle = '#2b2c2f';
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
    }

    // draw other players (from realtime DB)
    for(const uname in otherPlayers){
      const p = otherPlayers[uname];
      // draw nickname above
      const nickX = p.x || 100;
      const nickY = (p.y || GROUND_Y) - (p.h || 64) - 18;
      // nickname background
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const text = uname + (p.coin !== undefined ? ' ✦' + p.coin : '');
      ctx.font = '14px system-ui';
      const tw = ctx.measureText(text).width;
      ctx.fillRect(nickX - tw/2 - 8, nickY - 14, tw + 16, 20);
      ctx.fillStyle = '#fff'; ctx.fillText(text, nickX - tw/2, nickY);
      // draw remote hero as rectangle or sprite if available
      ctx.save();
      ctx.translate(nickX, p.y || GROUND_Y);
      ctx.scale((p.dir === -1) ? -1 : 1, 1);
      // try to use same sprite set if available
      const animSet = SPRITES[p.state] && SPRITES[p.state].length ? SPRITES[p.state] : (SPRITES['idle'] || []);
      const frameIndex = (p.frame || 0) % (animSet.length || 1);
      const img = animSet[frameIndex] || null;
      if(img && img.complete && img.naturalWidth){
        const scale = Math.max(1.0, Math.min(2.0, (H/720) * 1.6));
        const w = img.width * scale, h = img.height * scale;
        try { ctx.drawImage(img, -w/2, -h, w, h); } catch(e){ ctx.fillStyle='#8a8d90'; ctx.fillRect(-24, -64, 48, 64); }
      } else {
        ctx.fillStyle = '#8a8d90'; ctx.fillRect(-24, -64, 48, 64);
      }
      ctx.restore();
    }

    // draw my hero (local)
    const animSet = SPRITES[hero.state] && SPRITES[hero.state].length ? SPRITES[hero.state] : (SPRITES['idle'] || []);
    const frameIndex = hero.frame % (animSet.length || 1);
    const img = animSet[frameIndex] || null;
    if(img && img.complete && img.naturalWidth){
      const scale = Math.max(1.2, Math.min(2.0, (H/720) * 1.8));
      const w = img.width * scale, h = img.height * scale;
      ctx.save(); ctx.translate(hero.x, hero.y); ctx.scale(hero.dir, 1);
      try { ctx.drawImage(img, -w/2, -h, w, h); } catch(e){ ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h); }
      ctx.restore();
    } else {
      ctx.save(); ctx.translate(hero.x, hero.y);
      ctx.fillStyle = '#8a8d90'; ctx.fillRect(-hero.w/2, -hero.h, hero.w, hero.h);
      ctx.restore();
    }

    // my nickname above hero
    ctx.font = '14px system-ui';
    const myText = username + ' ✦' + (myCoin || 0);
    const mtw = ctx.measureText(myText).width;
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(hero.x - mtw/2 - 8, hero.y - hero.h - 20, mtw + 16, 20);
    ctx.fillStyle = '#fff'; ctx.fillText(myText, hero.x - mtw/2, hero.y - hero.h - 6);

    // debug info
    ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '14px system-ui';
    ctx.fillText(`State: ${hero.state} ${hero.stateLock ? '(locked)':''}`, 12, 60);
    ctx.fillText(`OnGround:${hero.onGround} vx:${hero.vx.toFixed(2)} vy:${hero.vy.toFixed(2)} Players:${Object.keys(otherPlayers).length}`, 12, 80);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(0,0,W,48);

  } catch(err){ console.error('draw error', err); }
}

/* GAME LOOP */
let lastTime = performance.now();
function loop(now){
  try {
    const dt = now - lastTime; lastTime = now;
    if(hero.state === 'die') { INPUT.left = INPUT.right = INPUT.jump = INPUT.attack = INPUT.crouch = false; }
    update(dt); draw();
  } catch(e){ console.error('main loop error', e); }
  requestAnimationFrame(loop);
}

/* start when sprites ready */
(function startWhenReady(){
  if(spriteReady || performance.now() - spriteWaitStart > SPRITE_WAIT_TIMEOUT){
    lastTime = performance.now();
    requestAnimationFrame(loop);
    showToast('Terhubung — game dimulai');
  } else { setTimeout(startWhenReady, 80); }
})();

/* HP bar update */
setInterval(()=>{ const hb = byId('hpFill'); if(hb) hb.style.width = hero.hp + '%'; }, 120);

/* presence & sync: write my state periodically and listen for other players is above (playersRef.on) */
/* throttle writes to ~10Hz */
let lastSync = 0;
let myCoin = 0;
async function writeMyState(){
  const now = Date.now();
  if(now - lastSync < 90) return; // ~11Hz
  lastSync = now;
  const payload = {
    username,
    x: Math.round(hero.x),
    y: Math.round(hero.y),
    vx: Math.round(hero.vx*100)/100,
    vy: Math.round(hero.vy*100)/100,
    dir: hero.dir,
    state: hero.state,
    frame: hero.frame,
    hp: hero.hp,
    coin: myCoin,
    lastSeen: firebase.database.ServerValue.TIMESTAMP
  };
  try {
    await myPlayerRef.set(payload);
    // ensure onDisconnect cleanup already set earlier
  } catch(e){ console.warn('writeMyState fail', e); }
}

/* poll writes inside game loop tick using interval */
setInterval(()=>{ writeMyState(); }, 100);

/* also listen for updates to my own user coin (if updated from elsewhere) */
db.ref('users/' + username + '/coin').on('value', s => { if(s.exists()) myCoin = s.val(); });

/* cleanup on unload */
window.addEventListener('beforeunload', ()=>{ try{ myPlayerRef.remove(); }catch(e){} });

/* show desktop hint */
if(window.innerWidth > 900) setTimeout(()=> showToast('Gunakan A/D atau Panah ← → untuk bergerak, Space untuk lompat, J untuk serang'), 1200);
</script>
</body>
</html>
